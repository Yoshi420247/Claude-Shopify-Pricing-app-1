<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Oil Slick Pad Pricing Suite</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        /* Custom scrollbar */
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #1f2937; }
        ::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #6b7280; }

        /* Animations */
        @keyframes pulse-dot {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .animate-pulse-dot { animation: pulse-dot 1.5s ease-in-out infinite; }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        .animate-spin { animation: spin 1s linear infinite; }

        /* Table row expansion */
        .expanded-content { display: none; }
        .expanded-content.open { display: table-row; }

        /* Inline editable */
        .editable:hover { background: #374151; cursor: pointer; }
        .editable:focus { outline: 2px solid #3b82f6; background: #1f2937; }
    </style>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'profit': '#22c55e',
                        'loss': '#ef4444',
                        'ai': '#3b82f6',
                        'warning': '#eab308',
                        'neutral': '#6b7280'
                    }
                }
            }
        }
    </script>
</head>
<body class="bg-gray-900 text-gray-100 min-h-screen">
    <div id="app" class="flex h-screen">
        <!-- Sidebar Navigation -->
        <nav class="w-56 bg-gray-800 border-r border-gray-700 flex flex-col">
            <div class="p-4 border-b border-gray-700">
                <h1 class="text-lg font-semibold text-white">Oil Slick Pad</h1>
                <p class="text-xs text-gray-400">Pricing Suite</p>
            </div>
            <div class="flex-1 py-4">
                <a href="#" onclick="navigateTo('dashboard')" id="nav-dashboard" class="nav-link flex items-center px-4 py-2.5 text-sm text-gray-300 hover:bg-gray-700 hover:text-white">
                    <svg class="w-5 h-5 mr-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6"/>
                    </svg>
                    Dashboard
                </a>
                <a href="#" onclick="navigateTo('products')" id="nav-products" class="nav-link flex items-center px-4 py-2.5 text-sm text-gray-300 hover:bg-gray-700 hover:text-white">
                    <svg class="w-5 h-5 mr-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2V6zM14 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2V6zM4 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2v-2zM14 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2v-2z"/>
                    </svg>
                    Products
                </a>
                <a href="#" onclick="navigateTo('settings')" id="nav-settings" class="nav-link flex items-center px-4 py-2.5 text-sm text-gray-300 hover:bg-gray-700 hover:text-white">
                    <svg class="w-5 h-5 mr-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"/>
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"/>
                    </svg>
                    Settings
                </a>
            </div>
            <div class="p-4 border-t border-gray-700">
                <div id="connection-status" class="text-xs text-gray-500">
                    <span class="inline-block w-2 h-2 rounded-full bg-gray-500 mr-2"></span>
                    Not configured
                </div>
            </div>
        </nav>

        <!-- Main Content Area -->
        <main class="flex-1 overflow-hidden flex flex-col">
            <!-- Dashboard Screen -->
            <section id="screen-dashboard" class="screen flex-1 overflow-auto p-6 hidden">
                <div class="max-w-7xl mx-auto">
                    <h2 class="text-2xl font-semibold mb-6">Dashboard</h2>

                    <!-- Health Metrics -->
                    <div class="grid grid-cols-4 gap-4 mb-6">
                        <div onclick="navigateTo('products')" class="bg-gray-800 border border-gray-700 rounded-lg p-4 cursor-pointer hover:border-gray-600">
                            <p class="text-sm text-gray-400 mb-1">Total Products</p>
                            <p id="metric-total" class="text-2xl font-semibold">—</p>
                        </div>
                        <div onclick="navigateTo('products'); applyFilter('sort', 'margin-asc')" class="bg-gray-800 border border-gray-700 rounded-lg p-4 cursor-pointer hover:border-gray-600">
                            <p class="text-sm text-gray-400 mb-1">Average Margin</p>
                            <p id="metric-margin" class="text-2xl font-semibold">—</p>
                        </div>
                        <div onclick="navigateTo('products'); applyFilter('status', 'Needs Analysis')" class="bg-gray-800 border border-gray-700 rounded-lg p-4 cursor-pointer hover:border-gray-600">
                            <p class="text-sm text-gray-400 mb-1">Analyzed</p>
                            <p id="metric-analyzed" class="text-2xl font-semibold">—</p>
                            <p id="metric-analyzed-pct" class="text-xs text-gray-500"></p>
                        </div>
                        <div onclick="navigateTo('products'); applyFilter('status', 'Has Suggestion')" class="bg-gray-800 border border-gray-700 rounded-lg p-4 cursor-pointer hover:border-gray-600">
                            <p class="text-sm text-gray-400 mb-1">Pending Updates</p>
                            <p id="metric-pending" class="text-2xl font-semibold text-ai">—</p>
                        </div>
                    </div>

                    <!-- Action Cards -->
                    <div id="action-cards" class="grid grid-cols-2 gap-4 mb-6">
                        <!-- Dynamic action cards will be inserted here -->
                    </div>

                    <!-- Recent Activity -->
                    <div class="bg-gray-800 border border-gray-700 rounded-lg">
                        <div class="px-4 py-3 border-b border-gray-700">
                            <h3 class="font-medium">Recent Activity</h3>
                        </div>
                        <div id="activity-feed" class="p-4 max-h-64 overflow-auto">
                            <p class="text-sm text-gray-500">No recent activity</p>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Products Screen -->
            <section id="screen-products" class="screen flex-1 overflow-hidden flex flex-col hidden">
                <!-- Filter Bar -->
                <div class="bg-gray-800 border-b border-gray-700 p-4 flex items-center gap-4 flex-wrap">
                    <div class="flex-1 min-w-[200px] max-w-md">
                        <input type="text" id="search-input" placeholder="Search products, SKUs, vendors..."
                            class="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-sm focus:outline-none focus:border-blue-500">
                    </div>
                    <select id="filter-status" class="bg-gray-700 border border-gray-600 rounded px-3 py-2 text-sm">
                        <option value="">All Status</option>
                        <option value="Needs Analysis">Needs Analysis</option>
                        <option value="Has Suggestion">Has Suggestion</option>
                        <option value="Updated">Updated</option>
                        <option value="Failed">Failed</option>
                        <option value="Negative Margin">Negative Margin</option>
                        <option value="Below Floor">Below Floor</option>
                        <option value="Missing Cost">Missing Cost</option>
                    </select>
                    <select id="filter-margin" class="bg-gray-700 border border-gray-600 rounded px-3 py-2 text-sm">
                        <option value="">All Margins</option>
                        <option value="negative">Negative (&lt;0%)</option>
                        <option value="low">Low (0-15%)</option>
                        <option value="target">Target (15-30%)</option>
                        <option value="high">High (&gt;30%)</option>
                    </select>
                    <select id="filter-vendor" class="bg-gray-700 border border-gray-600 rounded px-3 py-2 text-sm">
                        <option value="">All Vendors</option>
                    </select>
                    <select id="filter-sort" class="bg-gray-700 border border-gray-600 rounded px-3 py-2 text-sm">
                        <option value="name-asc">Name A-Z</option>
                        <option value="name-desc">Name Z-A</option>
                        <option value="price-asc">Price: Low to High</option>
                        <option value="price-desc">Price: High to Low</option>
                        <option value="margin-asc">Margin: Low to High</option>
                        <option value="margin-desc">Margin: High to Low</option>
                        <option value="analyzed-desc">Last Analyzed</option>
                    </select>
                    <button onclick="analyzeVisible()" class="bg-blue-600 hover:bg-blue-700 px-4 py-2 rounded text-sm flex items-center gap-2">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 3v4M3 5h4M6 17v4m-2-2h4m5-16l2.286 6.857L21 12l-5.714 2.143L13 21l-2.286-6.857L5 12l5.714-2.143L13 3z"/>
                        </svg>
                        Analyze All Visible
                    </button>
                    <button onclick="exportCSV()" class="bg-gray-700 hover:bg-gray-600 px-4 py-2 rounded text-sm flex items-center gap-2">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"/>
                        </svg>
                        Export CSV
                    </button>
                    <button onclick="clearAllSuggestions()" class="text-gray-400 hover:text-red-400 px-3 py-2 text-sm flex items-center gap-1" title="Clear all pricing suggestions">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
                        </svg>
                        Clear All
                    </button>
                </div>

                <!-- Product Table -->
                <div class="flex-1 overflow-auto">
                    <table class="w-full text-sm">
                        <thead class="bg-gray-800 sticky top-0">
                            <tr class="border-b border-gray-700">
                                <th class="w-10 px-4 py-3 text-left">
                                    <input type="checkbox" id="select-all" class="rounded bg-gray-700 border-gray-600">
                                </th>
                                <th class="w-14 px-2 py-3"></th>
                                <th class="px-4 py-3 text-left font-medium text-gray-400">Product</th>
                                <th class="w-28 px-4 py-3 text-left font-medium text-gray-400">SKU</th>
                                <th class="w-24 px-4 py-3 text-right font-medium text-gray-400">Price</th>
                                <th class="w-24 px-4 py-3 text-right font-medium text-gray-400">Cost</th>
                                <th class="w-20 px-4 py-3 text-right font-medium text-gray-400">Margin</th>
                                <th class="w-28 px-4 py-3 text-right font-medium text-gray-400">Suggested</th>
                                <th class="w-24 px-4 py-3 text-center font-medium text-gray-400">Status</th>
                                <th class="w-36 px-4 py-3 text-center font-medium text-gray-400">Actions</th>
                            </tr>
                        </thead>
                        <tbody id="product-table-body">
                            <!-- Products will be dynamically inserted here -->
                        </tbody>
                    </table>
                    <div id="empty-state" class="hidden p-8 text-center text-gray-500">
                        <svg class="w-16 h-16 mx-auto mb-4 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1" d="M20 7l-8-4-8 4m16 0l-8 4m8-4v10l-8 4m0-10L4 7m8 4v10M4 7v10l8 4"/>
                        </svg>
                        <p class="text-lg mb-2">No products loaded</p>
                        <p class="text-sm">Configure your Shopify API in Settings to get started</p>
                    </div>
                </div>

                <!-- Pagination -->
                <div class="bg-gray-800 border-t border-gray-700 px-4 py-3 flex items-center justify-between">
                    <div class="flex items-center gap-2">
                        <span class="text-sm text-gray-400">Show</span>
                        <select id="page-size" class="bg-gray-700 border border-gray-600 rounded px-2 py-1 text-sm">
                            <option value="25">25</option>
                            <option value="50" selected>50</option>
                            <option value="100">100</option>
                            <option value="250">250</option>
                        </select>
                        <span class="text-sm text-gray-400">per page</span>
                    </div>
                    <div class="flex items-center gap-2">
                        <button id="prev-page" class="px-3 py-1 bg-gray-700 rounded text-sm disabled:opacity-50" disabled>Previous</button>
                        <span id="page-info" class="text-sm text-gray-400">Page 1 of 1</span>
                        <button id="next-page" class="px-3 py-1 bg-gray-700 rounded text-sm disabled:opacity-50" disabled>Next</button>
                    </div>
                    <div class="text-sm text-gray-400">
                        <span id="showing-count">0</span> products
                    </div>
                </div>

                <!-- Bulk Action Bar -->
                <div id="bulk-action-bar" class="hidden bg-gray-800 border-t border-blue-500 px-4 py-3 flex items-center justify-between">
                    <span id="selected-count" class="text-sm font-medium">0 products selected</span>
                    <div class="flex items-center gap-3">
                        <button onclick="analyzeSelected()" class="bg-blue-600 hover:bg-blue-700 px-4 py-2 rounded text-sm flex items-center gap-2">
                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 3v4M3 5h4M6 17v4m-2-2h4m5-16l2.286 6.857L21 12l-5.714 2.143L13 21l-2.286-6.857L5 12l5.714-2.143L13 3z"/>
                            </svg>
                            Analyze Selected
                        </button>
                        <button id="accept-all-btn" onclick="acceptAllSelected()" class="bg-green-600 hover:bg-green-700 px-4 py-2 rounded text-sm flex items-center gap-2 disabled:opacity-50" disabled>
                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"/>
                            </svg>
                            Accept All Suggestions
                        </button>
                        <button id="stop-btn" onclick="stopProcessing()" class="hidden bg-red-600 hover:bg-red-700 px-4 py-2 rounded text-sm flex items-center gap-2">
                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 10a1 1 0 011-1h4a1 1 0 011 1v4a1 1 0 01-1 1h-4a1 1 0 01-1-1v-4z"/>
                            </svg>
                            Stop
                        </button>
                    </div>
                    <button onclick="deselectAll()" class="text-sm text-gray-400 hover:text-white">Deselect All</button>
                </div>
            </section>

            <!-- Settings Screen -->
            <section id="screen-settings" class="screen flex-1 overflow-auto p-6 hidden">
                <div class="max-w-3xl mx-auto">
                    <h2 class="text-2xl font-semibold mb-6">Settings</h2>

                    <!-- API Connections -->
                    <div class="bg-gray-800 border border-gray-700 rounded-lg mb-6">
                        <div class="px-4 py-3 border-b border-gray-700">
                            <h3 class="font-medium">API Connections</h3>
                        </div>
                        <div class="p-4 space-y-4">
                            <div>
                                <label class="block text-sm text-gray-400 mb-1">Shopify Store Name</label>
                                <div class="flex items-center gap-2">
                                    <input type="text" id="shopify-store" value="oil-slick-pad"
                                        class="flex-1 bg-gray-700 border border-gray-600 rounded px-3 py-2 text-sm" readonly>
                                    <span class="text-gray-400">.myshopify.com</span>
                                </div>
                                <p class="text-xs text-gray-500 mt-1">Pre-filled for your store</p>
                            </div>
                            <div>
                                <label class="block text-sm text-gray-400 mb-1">Shopify Admin API Token</label>
                                <input type="text" id="shopify-token" placeholder="shpat_xxxxx"
                                    class="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-sm">
                                <p class="text-xs text-gray-500 mt-1">Requires read_products, write_products, read_inventory scopes</p>
                            </div>
                            <div>
                                <label class="block text-sm text-gray-400 mb-1">OpenAI API Key</label>
                                <input type="text" id="openai-key" placeholder="sk-xxxxx"
                                    class="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-sm">
                                <p class="text-xs text-gray-500 mt-1">Will use GPT-4o or latest available model</p>
                            </div>
                            <div>
                                <label class="block text-sm text-gray-400 mb-1">Brave Search API Key</label>
                                <input type="text" id="brave-key" placeholder="BSAxxxxx"
                                    class="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-sm">
                            </div>
                            <div class="flex gap-3 pt-2">
                                <button onclick="testConnections()" class="bg-gray-700 hover:bg-gray-600 px-4 py-2 rounded text-sm">
                                    Test Connections
                                </button>
                                <button onclick="saveSettings()" class="bg-blue-600 hover:bg-blue-700 px-4 py-2 rounded text-sm">
                                    Save
                                </button>
                            </div>
                            <div id="connection-results" class="hidden space-y-2 pt-2"></div>
                        </div>
                    </div>

                    <!-- Pricing Rules -->
                    <div class="bg-gray-800 border border-gray-700 rounded-lg mb-6">
                        <div class="px-4 py-3 border-b border-gray-700">
                            <h3 class="font-medium">Pricing Rules</h3>
                            <p class="text-xs text-gray-500">The AI will use these as guardrails</p>
                        </div>
                        <div class="p-4 space-y-6">
                            <!-- Margin Floors -->
                            <div>
                                <h4 class="text-sm font-medium text-gray-300 mb-3">Margin Floors</h4>
                                <div class="space-y-4">
                                    <div>
                                        <div class="flex justify-between text-sm mb-1">
                                            <label class="text-gray-400">Minimum Margin %</label>
                                            <span id="min-margin-value" class="text-white">20%</span>
                                        </div>
                                        <input type="range" id="min-margin" min="0" max="50" value="20"
                                            class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                                    </div>
                                    <div>
                                        <label class="block text-sm text-gray-400 mb-1">Minimum Margin $</label>
                                        <input type="number" id="min-margin-dollars" value="3.00" step="0.50" min="0"
                                            class="w-32 bg-gray-700 border border-gray-600 rounded px-3 py-2 text-sm">
                                    </div>
                                    <div>
                                        <div class="flex justify-between text-sm mb-1">
                                            <label class="text-gray-400">Clearance Minimum Margin %</label>
                                            <span id="clearance-margin-value" class="text-white">5%</span>
                                        </div>
                                        <input type="range" id="clearance-margin" min="0" max="20" value="5"
                                            class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                                    </div>
                                </div>
                            </div>

                            <!-- Price Ceilings -->
                            <div>
                                <h4 class="text-sm font-medium text-gray-300 mb-3">Price Ceilings</h4>
                                <div class="space-y-4">
                                    <div class="flex items-center justify-between">
                                        <label class="text-sm text-gray-400">Never exceed MSRP</label>
                                        <button id="respect-msrp" onclick="toggleSwitch(this)"
                                            class="relative w-11 h-6 bg-blue-600 rounded-full transition-colors" data-enabled="true">
                                            <span class="absolute left-5 top-0.5 w-5 h-5 bg-white rounded-full transition-transform"></span>
                                        </button>
                                    </div>
                                    <div>
                                        <div class="flex justify-between text-sm mb-1">
                                            <label class="text-gray-400">Max % above highest competitor</label>
                                            <span id="max-above-value" class="text-white">5%</span>
                                        </div>
                                        <input type="range" id="max-above" min="0" max="25" value="5"
                                            class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                                    </div>
                                </div>
                            </div>

                            <!-- Price Change Governance -->
                            <div>
                                <h4 class="text-sm font-medium text-gray-300 mb-3">Price Change Governance</h4>
                                <div class="space-y-4">
                                    <div>
                                        <div class="flex justify-between text-sm mb-1">
                                            <label class="text-gray-400">Max single increase %</label>
                                            <span id="max-increase-value" class="text-white">10%</span>
                                        </div>
                                        <input type="range" id="max-increase" min="1" max="25" value="10"
                                            class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                                    </div>
                                    <div>
                                        <div class="flex justify-between text-sm mb-1">
                                            <label class="text-gray-400">Max single decrease %</label>
                                            <span id="max-decrease-value" class="text-white">15%</span>
                                        </div>
                                        <input type="range" id="max-decrease" min="1" max="30" value="15"
                                            class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                                    </div>
                                </div>
                            </div>

                            <!-- Rounding -->
                            <div>
                                <h4 class="text-sm font-medium text-gray-300 mb-3">Rounding</h4>
                                <select id="rounding-style" class="bg-gray-700 border border-gray-600 rounded px-3 py-2 text-sm">
                                    <option value="psychological">Psychological (.99 endings)</option>
                                    <option value="clean">Clean (.00 endings)</option>
                                    <option value="none">No rounding</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    <!-- Store Context -->
                    <div class="bg-gray-800 border border-gray-700 rounded-lg mb-6">
                        <div class="px-4 py-3 border-b border-gray-700">
                            <h3 class="font-medium">Store Context</h3>
                        </div>
                        <div class="p-4">
                            <label class="block text-sm text-gray-400 mb-1">Product Niche & Context</label>
                            <textarea id="product-niche" rows="3" placeholder="e.g., Heady glass, American-made dab tools, concentrate accessories..."
                                class="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-sm"></textarea>
                            <p class="text-xs text-gray-500 mt-1">The AI uses this to generate better search queries and evaluate competitor relevance</p>
                        </div>
                    </div>

                    <!-- Processing Settings -->
                    <div class="bg-gray-800 border border-gray-700 rounded-lg">
                        <div class="px-4 py-3 border-b border-gray-700">
                            <h3 class="font-medium">Processing Settings</h3>
                        </div>
                        <div class="p-4 space-y-4">
                            <div>
                                <div class="flex justify-between text-sm mb-1">
                                    <label class="text-gray-400">Parallel Operations</label>
                                    <span id="concurrency-value" class="text-white">20</span>
                                </div>
                                <input type="range" id="concurrency" min="1" max="30" value="20"
                                    class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                                <p class="text-xs text-gray-500 mt-1">Shopify Plus allows higher limits</p>
                            </div>
                            <div class="flex items-center justify-between">
                                <label class="text-sm text-gray-400">Auto-save analysis results</label>
                                <button id="auto-save" onclick="toggleSwitch(this)"
                                    class="relative w-11 h-6 bg-blue-600 rounded-full transition-colors" data-enabled="true">
                                    <span class="absolute left-5 top-0.5 w-5 h-5 bg-white rounded-full transition-transform"></span>
                                </button>
                            </div>
                        </div>
                    </div>

                    <div class="mt-6 flex gap-3">
                        <button onclick="saveSettings()" class="bg-blue-600 hover:bg-blue-700 px-6 py-2 rounded text-sm font-medium">
                            Save All Settings
                        </button>
                        <button onclick="loadProducts()" class="bg-gray-700 hover:bg-gray-600 px-6 py-2 rounded text-sm font-medium">
                            Refresh Products
                        </button>
                    </div>
                </div>
            </section>
        </main>
    </div>

    <!-- Expanded Product Detail Modal -->
    <div id="product-modal" class="hidden fixed inset-0 bg-black/50 z-50 overflow-auto">
        <div class="min-h-screen flex items-start justify-center p-4 pt-20">
            <div class="bg-gray-800 border border-gray-700 rounded-lg w-full max-w-4xl">
                <div class="flex items-center justify-between px-6 py-4 border-b border-gray-700">
                    <h3 id="modal-product-title" class="text-lg font-medium">Product Details</h3>
                    <button onclick="closeModal()" class="text-gray-400 hover:text-white">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                        </svg>
                    </button>
                </div>
                <div id="modal-content" class="p-6">
                    <!-- Dynamic content -->
                </div>
            </div>
        </div>
    </div>

    <!-- Toast Notifications -->
    <div id="toast-container" class="fixed bottom-4 right-4 z-50 space-y-2"></div>

    <script>
    // ============================================================================
    // STATE MANAGEMENT
    // ============================================================================
    const state = {
        products: [],
        filteredProducts: [],
        selectedProducts: new Set(),
        currentPage: 1,
        pageSize: 50,
        processing: false,
        stopRequested: false,
        activityLog: [],
        analysisCache: {} // productId -> analysis result
    };

    // Helper to strip large fields before saving to localStorage
    function getProductsForStorage(products) {
        return products.map(p => ({
            ...p,
            description: '', // Don't store descriptions - they're too large
            descriptionHtml: ''
        }));
    }

    // ============================================================================
    // SETTINGS MANAGEMENT
    // ============================================================================
    function loadSettings() {
        const settings = JSON.parse(localStorage.getItem('oilslick_settings') || '{}');

        // API Keys
        document.getElementById('shopify-token').value = settings.shopifyToken || '';
        document.getElementById('openai-key').value = settings.openaiKey || '';
        document.getElementById('brave-key').value = settings.braveKey || '';

        // Pricing Rules
        if (settings.minMargin !== undefined) {
            document.getElementById('min-margin').value = settings.minMargin;
            document.getElementById('min-margin-value').textContent = settings.minMargin + '%';
        }
        if (settings.minMarginDollars !== undefined) {
            document.getElementById('min-margin-dollars').value = settings.minMarginDollars;
        }
        if (settings.clearanceMargin !== undefined) {
            document.getElementById('clearance-margin').value = settings.clearanceMargin;
            document.getElementById('clearance-margin-value').textContent = settings.clearanceMargin + '%';
        }
        if (settings.respectMsrp !== undefined) {
            const btn = document.getElementById('respect-msrp');
            btn.dataset.enabled = settings.respectMsrp;
            updateSwitchVisual(btn);
        }
        if (settings.maxAbove !== undefined) {
            document.getElementById('max-above').value = settings.maxAbove;
            document.getElementById('max-above-value').textContent = settings.maxAbove + '%';
        }
        if (settings.maxIncrease !== undefined) {
            document.getElementById('max-increase').value = settings.maxIncrease;
            document.getElementById('max-increase-value').textContent = settings.maxIncrease + '%';
        }
        if (settings.maxDecrease !== undefined) {
            document.getElementById('max-decrease').value = settings.maxDecrease;
            document.getElementById('max-decrease-value').textContent = settings.maxDecrease + '%';
        }
        if (settings.roundingStyle) {
            document.getElementById('rounding-style').value = settings.roundingStyle;
        }
        if (settings.productNiche) {
            document.getElementById('product-niche').value = settings.productNiche;
        }
        if (settings.concurrency !== undefined) {
            document.getElementById('concurrency').value = settings.concurrency;
            document.getElementById('concurrency-value').textContent = settings.concurrency;
        }
        if (settings.autoSave !== undefined) {
            const btn = document.getElementById('auto-save');
            btn.dataset.enabled = settings.autoSave;
            updateSwitchVisual(btn);
        }

        // Load cached data with error handling
        try {
            state.products = JSON.parse(localStorage.getItem('oilslick_products') || '[]');
        } catch (e) {
            state.products = [];
        }

        try {
            state.analysisCache = JSON.parse(localStorage.getItem('oilslick_analysis') || '{}');
            // Trim if too large (keep only 200 most recent)
            const entries = Object.entries(state.analysisCache);
            if (entries.length > 200) {
                entries.sort((a, b) => (b[1].analyzedAt || '').localeCompare(a[1].analyzedAt || ''));
                state.analysisCache = Object.fromEntries(entries.slice(0, 200));
                localStorage.setItem('oilslick_analysis', JSON.stringify(state.analysisCache));
                console.log('Trimmed analysis cache to 200 entries');
            }
        } catch (e) {
            console.warn('Clearing corrupted analysis cache');
            state.analysisCache = {};
            localStorage.removeItem('oilslick_analysis');
        }

        try {
            state.activityLog = JSON.parse(localStorage.getItem('oilslick_activity') || '[]').slice(-100);
        } catch (e) {
            state.activityLog = [];
        }

        updateConnectionStatus();
    }

    function saveSettings() {
        const settings = {
            shopifyToken: document.getElementById('shopify-token').value,
            openaiKey: document.getElementById('openai-key').value,
            braveKey: document.getElementById('brave-key').value,
            minMargin: parseInt(document.getElementById('min-margin').value),
            minMarginDollars: parseFloat(document.getElementById('min-margin-dollars').value),
            clearanceMargin: parseInt(document.getElementById('clearance-margin').value),
            respectMsrp: document.getElementById('respect-msrp').dataset.enabled === 'true',
            maxAbove: parseInt(document.getElementById('max-above').value),
            maxIncrease: parseInt(document.getElementById('max-increase').value),
            maxDecrease: parseInt(document.getElementById('max-decrease').value),
            roundingStyle: document.getElementById('rounding-style').value,
            productNiche: document.getElementById('product-niche').value,
            concurrency: parseInt(document.getElementById('concurrency').value),
            autoSave: document.getElementById('auto-save').dataset.enabled === 'true'
        };

        localStorage.setItem('oilslick_settings', JSON.stringify(settings));
        showToast('Settings saved', 'success');
        updateConnectionStatus();
    }

    function getSettings() {
        return JSON.parse(localStorage.getItem('oilslick_settings') || '{}');
    }

    function updateConnectionStatus() {
        const settings = getSettings();
        const statusEl = document.getElementById('connection-status');

        if (settings.shopifyToken && settings.openaiKey && settings.braveKey) {
            statusEl.innerHTML = '<span class="inline-block w-2 h-2 rounded-full bg-green-500 mr-2"></span>Connected';
        } else if (settings.shopifyToken || settings.openaiKey || settings.braveKey) {
            statusEl.innerHTML = '<span class="inline-block w-2 h-2 rounded-full bg-yellow-500 mr-2"></span>Partially configured';
        } else {
            statusEl.innerHTML = '<span class="inline-block w-2 h-2 rounded-full bg-gray-500 mr-2"></span>Not configured';
        }
    }

    // ============================================================================
    // NAVIGATION
    // ============================================================================
    function navigateTo(screen) {
        document.querySelectorAll('.screen').forEach(s => s.classList.add('hidden'));
        document.querySelectorAll('.nav-link').forEach(l => l.classList.remove('bg-gray-700', 'text-white'));

        document.getElementById(`screen-${screen}`).classList.remove('hidden');
        document.getElementById(`nav-${screen}`).classList.add('bg-gray-700', 'text-white');

        if (screen === 'dashboard') {
            updateDashboard();
        } else if (screen === 'products') {
            renderProducts();
        }
    }

    // ============================================================================
    // API INTEGRATIONS
    // ============================================================================
    const CORS_PROXIES = [
        'https://corsproxy.io/?',
        'https://api.allorigins.win/raw?url=',
        'https://cors-anywhere.herokuapp.com/'
    ];
    let activeCorsProxyIndex = 0;
    let CORS_PROXY = CORS_PROXIES[0];

    // Try next CORS proxy if current one fails
    function switchCorsProxy() {
        activeCorsProxyIndex = (activeCorsProxyIndex + 1) % CORS_PROXIES.length;
        CORS_PROXY = CORS_PROXIES[activeCorsProxyIndex];
        console.log(`Switched to CORS proxy: ${CORS_PROXY}`);
        return CORS_PROXY;
    }

    async function testConnections() {
        const resultsEl = document.getElementById('connection-results');
        resultsEl.classList.remove('hidden');
        resultsEl.innerHTML = '<p class="text-sm text-gray-400">Testing connections...</p>';

        const results = [];

        // Test Shopify
        const shopifyToken = document.getElementById('shopify-token').value;
        if (shopifyToken) {
            try {
                const res = await fetch(`${CORS_PROXY}https://oil-slick-pad.myshopify.com/admin/api/2024-01/shop.json`, {
                    headers: { 'X-Shopify-Access-Token': shopifyToken }
                });
                if (res.ok) {
                    results.push({ name: 'Shopify', status: 'success', message: 'Connected' });
                } else {
                    results.push({ name: 'Shopify', status: 'error', message: `Error: ${res.status}` });
                }
            } catch (e) {
                results.push({ name: 'Shopify', status: 'error', message: e.message });
            }
        } else {
            results.push({ name: 'Shopify', status: 'warning', message: 'No token provided' });
        }

        // Test OpenAI
        const openaiKey = document.getElementById('openai-key').value;
        if (openaiKey) {
            try {
                const res = await fetch('https://api.openai.com/v1/models', {
                    headers: { 'Authorization': `Bearer ${openaiKey}` }
                });
                if (res.ok) {
                    results.push({ name: 'OpenAI', status: 'success', message: 'Connected' });
                } else {
                    results.push({ name: 'OpenAI', status: 'error', message: `Error: ${res.status}` });
                }
            } catch (e) {
                results.push({ name: 'OpenAI', status: 'error', message: e.message });
            }
        } else {
            results.push({ name: 'OpenAI', status: 'warning', message: 'No key provided' });
        }

        // Test Brave (use CORS proxy since Brave API doesn't support CORS)
        const braveKey = document.getElementById('brave-key').value;
        if (braveKey) {
            try {
                const res = await fetch(`${CORS_PROXY}https://api.search.brave.com/res/v1/web/search?q=test&count=1`, {
                    headers: { 'X-Subscription-Token': braveKey }
                });
                if (res.ok) {
                    const data = await res.json();
                    results.push({ name: 'Brave Search', status: 'success', message: 'Connected' });
                } else {
                    const errText = await res.text();
                    results.push({ name: 'Brave Search', status: 'error', message: `Error: ${res.status} - ${errText.slice(0, 100)}` });
                }
            } catch (e) {
                results.push({ name: 'Brave Search', status: 'error', message: e.message });
            }
        } else {
            results.push({ name: 'Brave Search', status: 'warning', message: 'No key provided' });
        }

        resultsEl.innerHTML = results.map(r => {
            const color = r.status === 'success' ? 'text-green-400' : r.status === 'error' ? 'text-red-400' : 'text-yellow-400';
            const icon = r.status === 'success' ? '✓' : r.status === 'error' ? '✗' : '!';
            return `<p class="text-sm ${color}">${icon} ${r.name}: ${r.message}</p>`;
        }).join('');
    }

    async function loadProducts() {
        const settings = getSettings();
        if (!settings.shopifyToken) {
            showToast('Please configure Shopify API token first', 'error');
            return;
        }

        showToast('Loading products with costs via GraphQL...', 'info');

        try {
            let allProducts = [];
            let hasNextPage = true;
            let cursor = null;
            let pageCount = 0;

            // GraphQL query to fetch products with inventory costs
            const query = `
                query getProductsWithCost($cursor: String) {
                    products(first: 100, after: $cursor) {
                        pageInfo {
                            hasNextPage
                            endCursor
                        }
                        edges {
                            node {
                                id
                                title
                                description
                                descriptionHtml
                                vendor
                                productType
                                handle
                                tags
                                status
                                featuredImage {
                                    url
                                }
                                variants(first: 100) {
                                    edges {
                                        node {
                                            id
                                            title
                                            sku
                                            price
                                            compareAtPrice
                                            inventoryItem {
                                                id
                                                unitCost {
                                                    amount
                                                    currencyCode
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            `;

            while (hasNextPage) {
                pageCount++;
                const res = await fetch(
                    `${CORS_PROXY}https://oil-slick-pad.myshopify.com/admin/api/2024-01/graphql.json`,
                    {
                        method: 'POST',
                        headers: {
                            'X-Shopify-Access-Token': settings.shopifyToken,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            query: query,
                            variables: { cursor: cursor }
                        })
                    }
                );

                if (!res.ok) throw new Error(`Shopify GraphQL error: ${res.status}`);

                const result = await res.json();

                if (result.errors) {
                    console.error('GraphQL errors:', result.errors);
                    throw new Error(result.errors[0]?.message || 'GraphQL query failed');
                }

                const products = result.data?.products;
                if (!products) throw new Error('No products data in response');

                // Process products from this page
                for (const edge of products.edges) {
                    const p = edge.node;
                    // Extract numeric ID from GraphQL global ID (gid://shopify/Product/123456)
                    const productId = p.id.split('/').pop();

                    allProducts.push({
                        id: productId,
                        title: p.title,
                        description: p.description || '',
                        descriptionHtml: p.descriptionHtml || '',
                        vendor: p.vendor,
                        productType: p.productType,
                        handle: p.handle,
                        tags: p.tags?.join(', ') || '',
                        status: p.status?.toLowerCase() || 'active',
                        image: p.featuredImage?.url || null,
                        variants: p.variants.edges.map(ve => {
                            const v = ve.node;
                            const variantId = v.id.split('/').pop();
                            const inventoryItemId = v.inventoryItem?.id?.split('/').pop();
                            const cost = v.inventoryItem?.unitCost?.amount;

                            return {
                                id: variantId,
                                title: v.title,
                                sku: v.sku,
                                price: parseFloat(v.price),
                                compareAtPrice: v.compareAtPrice ? parseFloat(v.compareAtPrice) : null,
                                cost: cost ? parseFloat(cost) : null,
                                inventoryItemId: inventoryItemId
                            };
                        })
                    });
                }

                showToast(`Loading products... (${allProducts.length} loaded)`, 'info');

                // Check for next page
                hasNextPage = products.pageInfo.hasNextPage;
                cursor = products.pageInfo.endCursor;

                // Safety limit
                if (pageCount > 100) {
                    console.warn('Hit pagination safety limit');
                    break;
                }
            }

            state.products = allProducts;

            // Count how many have costs
            let costCount = 0;
            for (const p of state.products) {
                for (const v of p.variants) {
                    if (v.cost !== null) costCount++;
                }
            }

            localStorage.setItem('oilslick_products', JSON.stringify(getProductsForStorage(state.products)));

            showToast(`Loaded ${state.products.length} products (${costCount} variants with costs)`, 'success');
            logActivity(`Loaded ${state.products.length} products with ${costCount} costs from Shopify`);

            populateFilters();
            renderProducts();
            updateDashboard();

        } catch (e) {
            console.error('Load products error:', e);
            showToast('Failed to load products: ' + e.message, 'error');
        }
    }

    // Keep REST-based cost loading as fallback (in case GraphQL doesn't work)
    async function loadInventoryCostsREST() {
        const settings = getSettings();

        // Collect all inventory item IDs
        const inventoryItemIds = [];
        const variantMap = new Map(); // inventoryItemId -> variant reference

        for (const product of state.products) {
            for (const variant of product.variants) {
                if (variant.inventoryItemId) {
                    // Ensure ID is treated as string to avoid large number issues
                    const idStr = String(variant.inventoryItemId);
                    inventoryItemIds.push(idStr);
                    variantMap.set(idStr, variant);
                }
            }
        }

        if (inventoryItemIds.length === 0) {
            console.log('No inventory items to fetch costs for');
            showToast('No inventory item IDs found - check product data', 'warning');
            return;
        }

        console.log(`Loading costs for ${inventoryItemIds.length} inventory items...`);
        console.log('Sample inventory IDs:', inventoryItemIds.slice(0, 5));
        showToast(`Loading costs for ${inventoryItemIds.length} items...`, 'info');

        let loadedCount = 0;
        let nullCostCount = 0;
        let errorCount = 0;

        // Batch fetch inventory items (max 100 per request per Shopify API)
        const batchSize = 100;
        for (let i = 0; i < inventoryItemIds.length; i += batchSize) {
            const batch = inventoryItemIds.slice(i, i + batchSize);
            const idsParam = batch.join(',');

            try {
                const url = `${CORS_PROXY}https://oil-slick-pad.myshopify.com/admin/api/2024-01/inventory_items.json?ids=${idsParam}`;
                console.log(`Fetching batch ${i}-${i + batchSize}, URL length: ${url.length}`);

                const res = await fetch(url, {
                    headers: { 'X-Shopify-Access-Token': settings.shopifyToken }
                });

                if (res.ok) {
                    const data = await res.json();
                    console.log(`Batch ${i}: Received ${data.inventory_items?.length || 0} items`);

                    if (data.inventory_items && Array.isArray(data.inventory_items)) {
                        for (const item of data.inventory_items) {
                            // Use string ID for lookup
                            const itemIdStr = String(item.id);
                            const variant = variantMap.get(itemIdStr);

                            if (variant) {
                                if (item.cost !== null && item.cost !== undefined && item.cost !== '') {
                                    variant.cost = parseFloat(item.cost);
                                    loadedCount++;
                                    // Log first few successful loads for debugging
                                    if (loadedCount <= 3) {
                                        console.log(`Loaded cost for item ${itemIdStr}: $${variant.cost}`);
                                    }
                                } else {
                                    nullCostCount++;
                                }
                            } else {
                                console.warn(`No variant found for inventory item ${itemIdStr}`);
                            }
                        }
                    }
                } else {
                    const errText = await res.text();
                    console.error(`Failed to fetch batch ${i}-${i + batchSize}:`, res.status, errText);
                    errorCount++;
                }
            } catch (e) {
                console.error(`Error fetching batch ${i}-${i + batchSize}:`, e);
                errorCount++;
            }

            // Update progress
            const progress = Math.min(100, Math.round(((i + batchSize) / inventoryItemIds.length) * 100));
            showToast(`Loading costs... ${progress}% (${loadedCount} found)`, 'info');
        }

        console.log(`Cost loading complete: ${loadedCount} with cost, ${nullCostCount} null/empty, ${errorCount} errors`);

        // Log some items without costs for debugging
        const itemsWithoutCost = [];
        for (const product of state.products) {
            for (const variant of product.variants) {
                if (!variant.cost && variant.inventoryItemId) {
                    itemsWithoutCost.push({
                        sku: variant.sku,
                        title: product.title,
                        inventoryItemId: variant.inventoryItemId
                    });
                }
            }
        }
        if (itemsWithoutCost.length > 0) {
            console.log(`Items without cost (first 20):`, itemsWithoutCost.slice(0, 20));
        }

        if (loadedCount > 0) {
            showToast(`Loaded ${loadedCount} costs (${nullCostCount} items have no cost in Shopify)`, 'success');
        } else if (nullCostCount > 0) {
            showToast(`Found ${nullCostCount} items but costs are empty in Shopify`, 'warning');
        } else if (errorCount > 0) {
            showToast(`Failed to load costs - check API permissions (read_inventory scope)`, 'error');
        } else {
            showToast(`No cost data found`, 'warning');
        }
    }

    // Diagnostic function - run in browser console: debugCost('SKU-HERE')
    window.debugCost = async function(sku) {
        const settings = getSettings();

        // Find the product/variant with this SKU
        let foundVariant = null;
        let foundProduct = null;
        for (const product of state.products) {
            for (const variant of product.variants) {
                if (variant.sku === sku || variant.sku?.includes(sku)) {
                    foundVariant = variant;
                    foundProduct = product;
                    break;
                }
            }
            if (foundVariant) break;
        }

        if (!foundVariant) {
            console.log(`SKU "${sku}" not found in loaded products`);
            return;
        }

        console.log('=== COST DIAGNOSTIC ===');
        console.log('Product:', foundProduct.title);
        console.log('Variant:', foundVariant);
        console.log('Inventory Item ID:', foundVariant.inventoryItemId);
        console.log('Current cost in app:', foundVariant.cost);

        if (!foundVariant.inventoryItemId) {
            console.log('ERROR: No inventory_item_id on this variant!');
            return;
        }

        // Fetch directly from Shopify
        console.log('Fetching from Shopify API...');
        try {
            const res = await fetch(
                `${CORS_PROXY}https://oil-slick-pad.myshopify.com/admin/api/2024-01/inventory_items/${foundVariant.inventoryItemId}.json`,
                { headers: { 'X-Shopify-Access-Token': settings.shopifyToken } }
            );

            if (res.ok) {
                const data = await res.json();
                console.log('Shopify API Response:', data);
                console.log('Cost from API:', data.inventory_item?.cost);
            } else {
                console.log('API Error:', res.status, await res.text());
            }
        } catch (e) {
            console.log('Fetch error:', e);
        }
    };

    async function updateProductPrice(productId, variantId, newPrice) {
        const settings = getSettings();

        try {
            const res = await fetch(
                `${CORS_PROXY}https://oil-slick-pad.myshopify.com/admin/api/2024-01/variants/${variantId}.json`,
                {
                    method: 'PUT',
                    headers: {
                        'X-Shopify-Access-Token': settings.shopifyToken,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        variant: { id: variantId, price: newPrice.toFixed(2) }
                    })
                }
            );

            if (!res.ok) throw new Error(`Update failed: ${res.status}`);

            // Update local state
            const product = state.products.find(p => p.id === productId);
            if (product) {
                const variant = product.variants.find(v => v.id === variantId);
                if (variant) {
                    const oldPrice = variant.price;
                    variant.price = newPrice;
                    logActivity(`Price updated: ${product.title} $${oldPrice.toFixed(2)} → $${newPrice.toFixed(2)}`);
                }
            }

            localStorage.setItem('oilslick_products', JSON.stringify(getProductsForStorage(state.products)));
            return true;

        } catch (e) {
            console.error('Update price error:', e);
            throw e;
        }
    }

    // Known wholesale/distributor domains to exclude
    const WHOLESALE_DOMAINS = [
        'alibaba.com', 'dhgate.com', 'made-in-china.com', 'globalsources.com',
        'wholesale', 'distributor', 'b2b', 'bulk', 'trade', 'reseller',
        'indiamart.com', '1688.com', 'ec21.com', 'tradekey.com',
        'wholesalecentral.com', 'dollardays.com', 'kole.com',
        'chinabrands.com', 'lightinthebox.com'
    ];

    // Known retail smoke/head shop domains (prioritize these)
    const RETAIL_SMOKE_SHOPS = [
        'smokea.com', 'dankgeek.com', 'everythingfor420.com', 'grasscity.com',
        'dailyhighclub.com', 'brotherswithglass.com', 'smokecartel.com',
        'headshop.com', 'thickassglass.com', 'gogopipes.com', 'kings-pipe.com',
        'tokeplanet.com', 'shopstaywild.com', 'paborito.com', 'stoners.com',
        'badassglass.com', 'dankstop.com', 'hemper.co', 'ssmokeshop.com',
        'worldofbongs.com', 'bongoutlet.com', 'aqualabtechnologies.com'
    ];

    // Step 1: Identify product using AI + image analysis
    async function identifyProduct(product, settings) {
        const messages = [
            {
                role: 'system',
                content: `You are an expert in smoke shop products, heady glass, dab tools, and concentrate accessories.
Your task is to identify what a product actually is, even if the title is incomplete, uses abbreviations, or jargon.

FIRST: Think through what you're seeing. Study the image (if provided), read the title and description carefully, and form a clear mental picture of the product.

CRITICAL: You must determine the ORIGIN/QUALITY TIER of this product. This is essential for accurate price comparisons.
The three tiers are:

1. "import" - Made in China/overseas mass-produced items
   - Signs: Generic designs, low price point ($5-50), no artist name, common materials
   - Brands: Generic, unbranded, or known import brands
   - Examples: Basic silicone pieces, standard glass bangers, generic dab tools

2. "domestic" - USA/American-made quality products
   - Signs: Higher price point ($30-200+), American brand names, quality materials
   - Brands: Higher-end American manufacturers
   - Examples: American quartz bangers, USA-made titanium tools, domestic glass

3. "heady" - Handmade art/artisan pieces
   - Signs: Artist name mentioned, unique designs, high price ($100-1000+), one-of-a-kind
   - Brands: Individual artists, "heady" in name, gallery pieces
   - Examples: Heady glass pendants, artist collaboration pieces, functional art

YOUR MAIN TASK: Write a clear, helpful product summary that describes what this product is, its quality level, and key features that would affect pricing. This summary should help a human understand exactly what they're selling.

Respond in JSON:
{
  "productType": "specific product category",
  "brand": "brand name or null",
  "identifiedAs": "your best guess of what this product is in plain English",
  "productSummary": "2-3 sentence description written for a human reviewer. Describe what this product is, its quality/tier, materials, notable features, and anything relevant to pricing. Be specific and helpful.",
  "keyFeatures": ["feature1", "feature2", "feature3"],
  "originTier": "import" | "domestic" | "heady",
  "originReasoning": "brief explanation of why you classified it this tier",
  "qualityIndicators": ["indicator1", "indicator2"],
  "pricingFactors": "what aspects of this product should influence its price",
  "searchQueries": ["query1", "query2", "query3"],
  "confidence": "high" | "medium" | "low",
  "notes": "any relevant observations or uncertainties"
}`
            }
        ];

        // Build user message with optional image
        const userContent = [];

        // Get clean description text (strip HTML)
        const descriptionText = product.description ||
            (product.descriptionHtml || '').replace(/<[^>]*>/g, ' ').replace(/\s+/g, ' ').trim();

        // Add text description with full product details
        userContent.push({
            type: 'text',
            text: `Identify this product and determine its origin/quality tier:

PRODUCT TITLE: ${product.title}

PRODUCT DESCRIPTION:
${descriptionText || 'No description available'}

METADATA:
- Vendor/Brand: ${product.vendor || 'Unknown'}
- Product Type: ${product.productType || 'Unknown'}
- Tags: ${product.tags || 'None'}
- SKU: ${product.variants[0]?.sku || 'Unknown'}
- Current Price: $${product.variants[0]?.price?.toFixed(2) || 'Unknown'}
- Compare At Price: ${product.variants[0]?.compareAtPrice ? '$' + product.variants[0].compareAtPrice.toFixed(2) : 'None'}

CRITICAL: Analyze ALL of the above information to determine:
1. What this product ACTUALLY is (not just what the title says)
2. Whether this is IMPORT (China mass-produced), DOMESTIC (USA-made), or HEADY (handmade art)
3. Key features that affect pricing (material, size, brand reputation, uniqueness)
${!product.image ? '\nNOTE: No product image available. Rely on title, description, and metadata. Be conservative with confidence.' : ''}`
        });

        // Add image if available (use high detail for better analysis)
        if (product.image) {
            // Optimize image URL for AI analysis
            let imageUrl = product.image;
            if (imageUrl.startsWith('//')) {
                imageUrl = 'https:' + imageUrl;
            }
            // Remove size constraints from Shopify CDN URLs
            imageUrl = imageUrl.replace(/_\d+x\d*\./, '.');

            userContent.push({
                type: 'image_url',
                image_url: { url: imageUrl, detail: 'high' }
            });
        }

        messages.push({ role: 'user', content: userContent });

        const res = await fetch('https://api.openai.com/v1/chat/completions', {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${settings.openaiKey}`,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                model: 'gpt-4o',
                messages: messages,
                temperature: 0.4,   // Increased for more nuanced reasoning
                max_tokens: 800,    // Increased for detailed analysis
                response_format: { type: 'json_object' }
            })
        });

        if (!res.ok) {
            const err = await res.json();
            throw new Error(err.error?.message || `OpenAI error: ${res.status}`);
        }

        const data = await res.json();
        return JSON.parse(data.choices[0].message.content);
    }

    // Step 2: Search and extract prices from competitor results
    async function searchCompetitors(product, productIdentity, settings, options = {}) {
        if (!settings.braveKey) {
            console.error('Brave API key not configured!');
            throw new Error('Brave API key not configured');
        }
        console.log(`Brave API key present: ${settings.braveKey.substring(0, 8)}...`);

        const isDeep = options.deep || false;
        const broadeningLevel = options.broadeningLevel || 0;
        const allResults = [];
        const seenUrls = new Set();

        // Generate focused search queries
        const brand = product.vendor || productIdentity.brand || '';
        const productType = productIdentity.productType || '';
        const productName = productIdentity.identifiedAs || product.title;
        const originTier = productIdentity.originTier || 'import';

        let queries = [];

        // Level 0: Specific product queries (first attempt)
        if (broadeningLevel === 0) {
            queries = [
                // AI-generated queries first
                ...(productIdentity.searchQueries || []),
                // Specific product searches
                `"${product.title}" price`,
                `${brand} ${productType} buy`,
                `${productName} smoke shop price`,
            ];

            // Deep mode: add more query variations
            if (isDeep) {
                queries.push(
                    `${productName} head shop`,
                    `buy ${productName} online`,
                    `${brand} ${productName}`.trim(),
                );
            }
        }
        // Level 1: Broader category queries (second attempt)
        else if (broadeningLevel === 1) {
            console.log(`[Broadening Level 1] Using category-based queries...`);
            queries = [
                `${productType} smoke shop price`,
                `${productType} head shop buy`,
                `${productType} online store`,
                `${productType} retail`,
                originTier === 'heady' ? `heady ${productType} price` : `${productType} price`,
                originTier === 'heady' ? 'heady glass pendant price' : null,
                originTier === 'heady' ? 'art glass pendant buy' : null,
                `buy ${productType} online`,
                `${productType} for sale`,
            ];
        }
        // Level 2: Very broad generic queries (third attempt)
        else if (broadeningLevel >= 2) {
            console.log(`[Broadening Level 2] Using very broad queries...`);
            // Use general category and similar product types
            const generalCategory = productType.toLowerCase().includes('pendant') ? 'glass pendant' :
                                   productType.toLowerCase().includes('tool') ? 'dab tool' :
                                   productType.toLowerCase().includes('banger') ? 'quartz banger' :
                                   productType.toLowerCase().includes('cap') ? 'carb cap' :
                                   productType.toLowerCase().includes('rig') ? 'dab rig' :
                                   productType || 'smoke shop accessories';

            queries = [
                `${generalCategory} smoke shop`,
                `${generalCategory} price`,
                `${generalCategory} online`,
                `buy ${generalCategory}`,
                `${generalCategory} head shop`,
                // Also try tier-specific broad searches
                originTier === 'heady' ? 'heady glass art price' : null,
                originTier === 'heady' ? 'handmade glass pendant' : null,
                originTier === 'domestic' ? 'american made glass price' : null,
                originTier === 'import' ? `cheap ${generalCategory}` : null,
                // Generic smoke shop searches
                'smoke shop glass prices',
                'head shop accessories',
            ];
        }

        queries = queries.filter(Boolean).slice(0, isDeep ? 10 : 6);
        const resultsPerQuery = isDeep ? 15 : 10;

        console.log(`[${isDeep ? 'DEEP' : 'Normal'}] Running ${queries.length} queries at broadening level ${broadeningLevel}...`);
        console.log(`Queries: ${queries.join(' | ')}`);

        // Debug: Log what inputs we have
        console.log(`Search inputs - brand: "${brand}", productType: "${productType}", productName: "${productName}", originTier: "${originTier}"`);
        console.log(`AI search queries: ${JSON.stringify(productIdentity.searchQueries || [])}`);

        if (queries.length === 0) {
            console.error('WARNING: No queries generated! Check productIdentity:', productIdentity);
        }

        // Search for results with retry logic
        for (const query of queries) {
            const retailQuery = `${query} -wholesale -bulk -distributor -alibaba -dhgate -ebay`;
            console.log(`Searching: "${retailQuery.substring(0, 60)}..."`);

            let searchSuccess = false;
            let retryCount = 0;
            const maxRetries = CORS_PROXIES.length;

            while (!searchSuccess && retryCount < maxRetries) {
                try {
                    const searchUrl = `${CORS_PROXY}https://api.search.brave.com/res/v1/web/search?q=${encodeURIComponent(retailQuery)}&count=${resultsPerQuery}`;
                    console.log(`  Using proxy: ${CORS_PROXY.substring(0, 30)}...`);

                    const res = await fetch(searchUrl, {
                        headers: { 'X-Subscription-Token': settings.braveKey },
                        timeout: 15000
                    });

                    console.log(`  Response status: ${res.status}`);

                    if (res.ok) {
                        const data = await res.json();
                        const resultCount = data.web?.results?.length || 0;
                        console.log(`  ✓ Got ${resultCount} results for "${query.substring(0, 30)}..."`);
                        for (const r of (data.web?.results || [])) {
                            if (!seenUrls.has(r.url)) {
                                seenUrls.add(r.url);
                                allResults.push({ ...r, searchQuery: query });
                            }
                        }
                        searchSuccess = true;
                    } else if (res.status === 403 || res.status === 429 || res.status === 0) {
                        // CORS or rate limit issue - try another proxy
                        const errorText = await res.text().catch(() => 'Unknown error');
                        console.warn(`  Proxy issue (${res.status}), trying next proxy...`);
                        switchCorsProxy();
                        retryCount++;
                    } else {
                        const errorText = await res.text();
                        console.error(`  Search returned ${res.status}: ${errorText.substring(0, 100)}`);
                        searchSuccess = true; // Don't retry for other errors
                    }
                } catch (e) {
                    console.warn(`  Fetch failed: ${e.message}, trying next proxy...`);
                    switchCorsProxy();
                    retryCount++;
                }
            }
        }

        console.log(`Found ${allResults.length} search results`);

        // Process results - extract prices from snippets and categorize
        const competitorsWithPrices = [];
        const excluded = [];
        const rawResults = []; // Keep raw results for AI fallback

        for (const result of allResults) {
            let domain;
            try {
                domain = new URL(result.url).hostname.replace('www.', '');
            } catch (e) {
                continue; // Skip invalid URLs
            }

            // Skip known wholesale/bad domains
            if (WHOLESALE_DOMAINS.some(w => domain.includes(w))) {
                excluded.push({ source: domain, url: result.url, reason: 'wholesale domain' });
                continue;
            }

            // Try to extract price from search snippet (title + description)
            const snippetText = `${result.title || ''} ${result.description || ''}`;
            const snippetPrice = extractPriceFromSnippet(snippetText);

            // Check if this is a known reliable smoke shop domain
            const isKnownRetailer = RETAIL_SMOKE_SHOPS.some(shop => domain.includes(shop));

            if (snippetPrice) {
                competitorsWithPrices.push({
                    source: domain,
                    url: result.url,
                    title: result.title,
                    price: snippetPrice,
                    extractionMethod: 'search snippet',
                    isKnownRetailer: isKnownRetailer,
                    inStock: true
                });
                console.log(`  ✓ ${domain}: $${snippetPrice} (from snippet)`);
            } else {
                // Keep as raw result for AI to analyze
                rawResults.push({
                    source: domain,
                    url: result.url,
                    title: result.title,
                    description: result.description,
                    isKnownRetailer: isKnownRetailer
                });
            }
        }

        // For known retailers without snippet prices, try page fetch (more in deep mode)
        const pageFetchLimit = isDeep ? 10 : 5;
        const knownRetailersWithoutPrice = rawResults.filter(r => r.isKnownRetailer).slice(0, pageFetchLimit);
        for (const result of knownRetailersWithoutPrice) {
            try {
                console.log(`  Fetching ${result.source}...`);
                const priceData = await extractPriceFromPage(result.url, settings);

                if (priceData.price && priceData.price > 0) {
                    competitorsWithPrices.push({
                        source: result.source,
                        url: result.url,
                        title: result.title,
                        price: priceData.price,
                        extractionMethod: priceData.method,
                        isKnownRetailer: true,
                        inStock: priceData.inStock !== false
                    });
                    console.log(`  ✓ ${result.source}: $${priceData.price} (${priceData.method})`);
                    // Remove from raw results since we got a price
                    const idx = rawResults.indexOf(result);
                    if (idx > -1) rawResults.splice(idx, 1);
                }
            } catch (e) {
                console.warn(`  ✗ ${result.source}: fetch failed`);
            }
        }

        console.log(`Extracted ${competitorsWithPrices.length} prices, ${rawResults.length} unpriced results`);

        return {
            competitors: competitorsWithPrices,
            rawResults: rawResults, // Results without prices for AI to analyze
            excluded: excluded,
            queries: queries
        };
    }

    // Extract price from search snippet text
    function extractPriceFromSnippet(text) {
        if (!text) return null;

        // Look for price patterns like $XX.XX or $X,XXX.XX
        const pricePatterns = [
            /\$\s*([\d,]+\.\d{2})\b/g,  // $XX.XX
            /\$([\d,]+)\s/g,            // $XX (whole dollars)
            /USD\s*([\d,]+\.?\d*)/gi,   // USD XX.XX
            /Price:\s*\$?([\d,]+\.?\d*)/gi, // Price: XX.XX
        ];

        const prices = [];
        for (const pattern of pricePatterns) {
            const matches = [...text.matchAll(pattern)];
            for (const match of matches) {
                const price = parseFloat(match[1].replace(/,/g, ''));
                // Sanity check: reasonable product price range
                if (price >= 1 && price <= 5000) {
                    prices.push(price);
                }
            }
        }

        if (prices.length === 0) return null;

        // If multiple prices found, prefer the first one (usually the main price)
        // But filter out very low prices that might be shipping costs
        const mainPrices = prices.filter(p => p >= 5);
        return mainPrices.length > 0 ? mainPrices[0] : prices[0];
    }

    // Extract price from a competitor page
    async function extractPriceFromPage(url, settings) {
        try {
            const res = await fetch(`${CORS_PROXY}${url}`, {
                headers: { 'Accept': 'text/html' }
            });

            if (!res.ok) {
                return { price: null, reason: `HTTP ${res.status}` };
            }

            const html = await res.text();

            // Method 1: JSON-LD Schema.org Product markup (most reliable)
            const jsonLdMatch = html.match(/<script[^>]*type=["']application\/ld\+json["'][^>]*>([\s\S]*?)<\/script>/gi);
            if (jsonLdMatch) {
                for (const match of jsonLdMatch) {
                    try {
                        const jsonContent = match.replace(/<script[^>]*>|<\/script>/gi, '');
                        const data = JSON.parse(jsonContent);
                        const price = extractPriceFromSchema(data);
                        if (price) {
                            return { price, method: 'schema.org', productName: data.name };
                        }
                    } catch (e) {}
                }
            }

            // Method 2: Open Graph price meta tags
            const ogPriceMatch = html.match(/<meta[^>]*property=["']og:price:amount["'][^>]*content=["']([^"']+)["']/i) ||
                                 html.match(/<meta[^>]*content=["']([^"']+)["'][^>]*property=["']og:price:amount["']/i) ||
                                 html.match(/<meta[^>]*property=["']product:price:amount["'][^>]*content=["']([^"']+)["']/i);
            if (ogPriceMatch) {
                const price = parseFloat(ogPriceMatch[1]);
                if (price > 0) {
                    return { price, method: 'og:price' };
                }
            }

            // Method 3: Common price patterns in HTML
            // Look for price in common e-commerce patterns
            const pricePatterns = [
                // Shopify-style
                /<span[^>]*class=["'][^"']*price[^"']*["'][^>]*>\s*\$?([\d,]+\.?\d*)/gi,
                // Generic price classes
                /<[^>]*class=["'][^"']*product[_-]?price[^"']*["'][^>]*>\s*\$?([\d,]+\.?\d*)/gi,
                /<[^>]*class=["'][^"']*sale[_-]?price[^"']*["'][^>]*>\s*\$?([\d,]+\.?\d*)/gi,
                /<[^>]*class=["'][^"']*current[_-]?price[^"']*["'][^>]*>\s*\$?([\d,]+\.?\d*)/gi,
                // data-price attributes
                /data-price=["']?([\d.]+)["']?/gi,
                // itemprop price
                /<[^>]*itemprop=["']price["'][^>]*content=["']?([\d.]+)["']?/gi,
                /<[^>]*itemprop=["']price["'][^>]*>\s*\$?([\d,]+\.?\d*)/gi,
            ];

            for (const pattern of pricePatterns) {
                const matches = [...html.matchAll(pattern)];
                for (const match of matches) {
                    const price = parseFloat(match[1].replace(/,/g, ''));
                    // Sanity check: price should be reasonable ($1 - $10000)
                    if (price >= 1 && price <= 10000) {
                        return { price, method: 'html pattern' };
                    }
                }
            }

            // Method 4: Look for $ followed by number anywhere
            const dollarMatches = html.match(/\$\s*([\d,]+\.\d{2})/g);
            if (dollarMatches) {
                const prices = dollarMatches
                    .map(m => parseFloat(m.replace(/[$,\s]/g, '')))
                    .filter(p => p >= 1 && p <= 10000)
                    .sort((a, b) => a - b);

                if (prices.length > 0) {
                    // Return median-ish price (avoid shipping costs which are usually low, and total prices which are high)
                    const price = prices[Math.floor(prices.length / 2)];
                    return { price, method: 'dollar pattern' };
                }
            }

            // Check if out of stock
            const outOfStock = /out\s*of\s*stock|sold\s*out|unavailable|not\s*available/i.test(html);
            if (outOfStock) {
                return { price: null, reason: 'out of stock', inStock: false };
            }

            return { price: null, reason: 'no price pattern found' };

        } catch (e) {
            return { price: null, reason: e.message };
        }
    }

    // Helper to extract price from JSON-LD schema
    function extractPriceFromSchema(data) {
        if (Array.isArray(data)) {
            for (const item of data) {
                const price = extractPriceFromSchema(item);
                if (price) return price;
            }
            return null;
        }

        if (data['@type'] === 'Product' || data['@type'] === 'IndividualProduct') {
            const offers = data.offers;
            if (offers) {
                if (Array.isArray(offers)) {
                    for (const offer of offers) {
                        if (offer.price) return parseFloat(offer.price);
                    }
                } else if (offers.price) {
                    return parseFloat(offers.price);
                } else if (offers.lowPrice) {
                    return parseFloat(offers.lowPrice);
                }
            }
        }

        // Check nested @graph
        if (data['@graph']) {
            return extractPriceFromSchema(data['@graph']);
        }

        return null;
    }

    // Step 3: Analyze with AI using VERIFIED prices
    async function analyzeWithAI(product, competitorData, productIdentity, settings) {
        if (!settings.openaiKey) throw new Error('OpenAI API key not configured');

        const variant = product.variants[0];
        const cost = variant.cost || 0;
        const currentPrice = variant.price;
        const originTier = productIdentity.originTier || 'unknown';

        const systemPrompt = `You are a pricing analyst for Oil Slick Pad, an online smoke shop selling heady glass, dab tools, and concentrate accessories.
${settings.productNiche ? `Store context: ${settings.productNiche}` : ''}

YOUR PRIMARY GOAL: Find competitor prices and suggest competitive pricing.

CRITICAL: EXTRACT PRICES FROM SEARCH RESULTS!
- Look for $XX.XX patterns in titles AND descriptions
- Prices like "$24.99", "$45.00", "Price: $30" are all valid
- If you see ANY price in a search result, INCLUDE that competitor

Quality Tier (for context only - don't exclude based on tier):
- This product is: "${originTier}" tier
- Note tier differences but INCLUDE all relevant competitors

BE INCLUSIVE WITH COMPETITORS:
- Any smoke shop, head shop, or glass retailer is valid
- Same product CATEGORY is enough (pendant matches pendant, dabber matches dabber)
- Don't require exact product matches - similar items count
- ALWAYS include competitors you find - more data is better

Only exclude:
- Wholesale/B2B/distributor sites (selling bulk to businesses)
- Clearly unrelated products (e.g., car parts for glass search)

Known wholesale domains to EXCLUDE: ${WHOLESALE_DOMAINS.slice(0, 5).join(', ')}

Product was identified as: ${productIdentity.identifiedAs || 'Unknown'}
Product type: ${productIdentity.productType || 'Unknown'}
Origin/Quality tier: ${originTier} (${productIdentity.originReasoning || 'no reasoning provided'})
Key features: ${(productIdentity.keyFeatures || []).join(', ')}

Pricing Rules:
- Minimum margin: ${settings.minMargin || 20}% or $${settings.minMarginDollars || 3} (whichever is higher)
- Clearance minimum margin: ${settings.clearanceMargin || 5}%
- ${settings.respectMsrp ? 'Never exceed MSRP' : 'May exceed MSRP if justified'}
- Max ${settings.maxAbove || 5}% above highest retail competitor
- Max price increase: ${settings.maxIncrease || 10}%
- Max price decrease: ${settings.maxDecrease || 15}%
- Rounding style: ${settings.roundingStyle || 'psychological'}

IMPORTANT: You MUST include the FULL URL for each competitor source so prices can be manually verified.

Respond in JSON format:
{
  "suggestedPrice": number,
  "confidence": "high" | "medium" | "low",
  "confidenceReason": "string explaining confidence level",
  "summary": "1-2 sentence recommendation explanation",
  "reasoning": ["step1", "step2", "step3"],
  "productMatch": {
    "identifiedAs": "what you believe this product is",
    "originTier": "import|domestic|heady",
    "matchConfidence": "high" | "medium" | "low",
    "matchNotes": "notes on product identification and tier"
  },
  "competitorAnalysis": {
    "kept": [{"source": "store name", "url": "FULL URL to product page", "price": number, "productMatch": "exact|similar|equivalent", "tierMatch": "same|different", "reason": "why kept"}],
    "excluded": [{"source": "domain", "url": "full URL", "reason": "wholesale|marketplace|out of stock|different product|wrong tier|etc"}],
    "low": number | null,
    "median": number | null,
    "high": number | null,
    "retailCount": number
  },
  "priceFloor": number,
  "priceCeiling": number,
  "marketPosition": "below market" | "at market" | "above market" | "premium" | "unknown"
}`;

        // Build competitor sections
        const verifiedPrices = competitorData.competitors || [];
        const rawResults = competitorData.rawResults || [];
        const excludedResults = competitorData.excluded || [];

        // Debug logging
        console.log(`AI Input - Verified prices: ${verifiedPrices.length}, Raw results: ${rawResults.length}, Excluded: ${excludedResults.length}`);

        let competitorSection = '';

        // Section 1: Verified prices (extracted from snippets or pages)
        if (verifiedPrices.length > 0) {
            competitorSection = `EXTRACTED COMPETITOR PRICES (${verifiedPrices.length} found):
${verifiedPrices.map((c, i) => `${i + 1}. ${c.source}: $${c.price.toFixed(2)}${c.isKnownRetailer ? ' [KNOWN RETAILER]' : ''}
   URL: ${c.url}
   Title: ${c.title}
   Source: ${c.extractionMethod}`).join('\n\n')}`;
        }

        // Section 2: Raw results without prices (AI should try to identify prices or analyze)
        if (rawResults.length > 0) {
            competitorSection += `\n\nADDITIONAL SEARCH RESULTS (${rawResults.length} found - look for prices in titles/descriptions):
${rawResults.slice(0, 15).map((r, i) => `${i + 1}. ${r.source}${r.isKnownRetailer ? ' [KNOWN RETAILER]' : ''}
   URL: ${r.url}
   Title: ${r.title}
   Description: ${(r.description || '').slice(0, 300)}`).join('\n\n')}`;
        }

        if (verifiedPrices.length === 0 && rawResults.length === 0) {
            competitorSection = 'NO COMPETITOR RESULTS FOUND - search returned no relevant results';
        }

        if (excludedResults.length > 0) {
            competitorSection += `\n\nEXCLUDED (${excludedResults.length}): ${excludedResults.slice(0, 5).map(e => `${e.source} (${e.reason})`).join(', ')}`;
        }

        // Get clean description for pricing context
        const descText = (product.description || product.descriptionHtml?.replace(/<[^>]*>/g, ' ') || '').substring(0, 400);

        const userPrompt = `Analyze pricing for this product:

PRODUCT INFO:
- Title: ${product.title}
- Vendor: ${product.vendor || 'Unknown'}
- Type: ${product.productType || 'Unknown'}
- Current Price: $${currentPrice.toFixed(2)}
- Cost: ${cost > 0 ? '$' + cost.toFixed(2) : 'Unknown'}
${variant.compareAtPrice ? `- MSRP/Compare At: $${variant.compareAtPrice.toFixed(2)}` : ''}
${descText ? `- Description: ${descText}${descText.length >= 400 ? '...' : ''}` : ''}

AI PRODUCT IDENTIFICATION:
- Identified as: ${productIdentity.identifiedAs || 'Unknown'}
- Product type: ${productIdentity.productType || 'Unknown'}
- Brand: ${productIdentity.brand || 'Unknown'}
- ORIGIN/QUALITY TIER: ${originTier.toUpperCase()} - ${productIdentity.originReasoning || 'Unknown'}
- Key features: ${(productIdentity.keyFeatures || []).join(', ')}
- Identification confidence: ${productIdentity.confidence || 'Unknown'}

${competitorSection}

Instructions:
1. IMPORTANT: Extract prices from search results! Look for $XX.XX patterns in titles AND descriptions
2. Review EXTRACTED PRICES first - these are verified prices we found
3. Then scan ADDITIONAL SEARCH RESULTS for ANY price mentions (e.g., "$24.99", "Price: $30")
4. BE INCLUSIVE - keep any result that sells similar products, even if not exact match
5. For competitor matching: same category is enough (e.g., "glass pendant" matches "glass pendant")
6. PREFER same quality tier but INCLUDE different tiers with notes - don't exclude just for tier
7. Any online retailer selling glass/smoke products counts as a valid competitor
8. If you find ANY prices at all, use them for analysis
9. Calculate suggested price based on whatever competitor data you can find
10. Only use "low confidence" if literally zero prices found anywhere in the results`;

        const res = await fetch('https://api.openai.com/v1/chat/completions', {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${settings.openaiKey}`,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                model: 'gpt-4o',
                messages: [
                    { role: 'system', content: systemPrompt },
                    { role: 'user', content: userPrompt }
                ],
                temperature: 0.5,   // Increased for creative pricing reasoning
                max_tokens: 2000,   // Increased for detailed competitor analysis
                response_format: { type: 'json_object' }
            })
        });

        if (!res.ok) {
            const err = await res.json();
            throw new Error(err.error?.message || `OpenAI error: ${res.status}`);
        }

        const data = await res.json();
        const analysis = JSON.parse(data.choices[0].message.content);

        return {
            ...analysis,
            productIdentity,
            searchQueries: competitorData.queries,
            analyzedAt: new Date().toISOString()
        };
    }

    // Step 4: Alternative search strategies when initial search fails
    async function tryAlternativeSearches(product, productIdentity, settings) {
        const brand = product.vendor || productIdentity.brand || '';
        const productType = productIdentity.productType || '';
        const originTier = productIdentity.originTier || 'import';

        // Generate broader/alternative queries
        const alternativeQueries = [
            // Category-based searches
            `${productType} smoke shop`,
            `${productType} head shop price`,
            `buy ${productType} online`,
            // Origin-tier specific
            originTier === 'heady' ? 'heady glass art price' : null,
            originTier === 'heady' ? 'glass pendant artist' : null,
            originTier === 'domestic' ? 'american made glass' : null,
            originTier === 'import' ? `cheap ${productType}` : null,
            // Brand searches if available
            brand ? `${brand} products` : null,
            brand ? `${brand} ${productType}` : null,
            // Generic category
            `${productType} price range`,
            `${productType} retail`
        ].filter(Boolean);

        const allResults = [];
        const seenUrls = new Set();

        for (const query of alternativeQueries.slice(0, 6)) {
            let searchSuccess = false;
            let retryCount = 0;

            while (!searchSuccess && retryCount < CORS_PROXIES.length) {
                try {
                    const res = await fetch(
                        `${CORS_PROXY}https://api.search.brave.com/res/v1/web/search?q=${encodeURIComponent(query + ' -wholesale -bulk')}&count=10`,
                        { headers: { 'X-Subscription-Token': settings.braveKey } }
                    );

                    if (res.ok) {
                        const data = await res.json();
                        for (const r of (data.web?.results || [])) {
                            if (!seenUrls.has(r.url)) {
                                seenUrls.add(r.url);
                                const snippetPrice = extractPriceFromSnippet(`${r.title} ${r.description}`);
                                allResults.push({
                                    ...r,
                                    price: snippetPrice,
                                    searchQuery: query
                                });
                            }
                        }
                        searchSuccess = true;
                    } else if (res.status === 403 || res.status === 429 || res.status === 0) {
                        switchCorsProxy();
                        retryCount++;
                    } else {
                        searchSuccess = true; // Don't retry for other errors
                    }
                } catch (e) {
                    console.warn(`Alt search failed for "${query}": ${e.message}`);
                    switchCorsProxy();
                    retryCount++;
                }
            }
        }

        return allResults;
    }

    // Step 5: Deep deliberation when competitor data is insufficient - includes visual analysis
    async function deliberatePricing(product, initialAnalysis, competitorData, productIdentity, settings) {
        const variant = product.variants[0];
        const cost = variant.cost || 0;
        const currentPrice = variant.price;
        const originTier = productIdentity.originTier || 'unknown';

        // Get description for context
        const descText = (product.description || product.descriptionHtml?.replace(/<[^>]*>/g, ' ') || '').substring(0, 500);

        // Alternative prices found in retry searches
        const altPrices = initialAnalysis.alternativePricesFound || [];
        const altPriceInfo = altPrices.length > 0
            ? `\nALTERNATIVE SEARCH PRICES FOUND: ${altPrices.map(p => '$' + p.toFixed(2)).join(', ')}`
            : '';

        const deliberationPrompt = `You are a senior pricing strategist. The initial pricing analysis found INSUFFICIENT competitor data. You MUST now determine a good price using ALL available information and reasoning.

${product.image ? 'IMPORTANT: A product image is attached. CAREFULLY EXAMINE IT to understand:' : 'NOTE: No product image available.'}
${product.image ? '- What exactly is this product?' : ''}
${product.image ? '- Quality indicators (materials, craftsmanship, brand marks)' : ''}
${product.image ? '- Size and complexity' : ''}
${product.image ? '- Whether it appears import/domestic/heady quality' : ''}
${product.image ? '- Any features that would affect pricing' : ''}

PRODUCT DETAILS:
- Title: ${product.title}
- Description: ${descText || 'None'}
- Vendor: ${product.vendor || 'Unknown'}
- Type: ${productIdentity.productType || product.productType || 'Unknown'}
- Quality Tier: ${originTier.toUpperCase()}
- Current Price: $${currentPrice.toFixed(2)}
- Cost: ${cost > 0 ? '$' + cost.toFixed(2) : 'Unknown'}
- Compare At: ${variant.compareAtPrice ? '$' + variant.compareAtPrice.toFixed(2) : 'None'}
${altPriceInfo}

INITIAL ANALYSIS RESULT:
- Suggested: $${initialAnalysis.suggestedPrice?.toFixed(2) || 'None'}
- Confidence: ${initialAnalysis.confidence}
- Competitors Found: ${initialAnalysis.competitorAnalysis?.retailCount || 0}
- Reason: ${initialAnalysis.confidenceReason || 'Unknown'}

YOUR TASK - DELIBERATE AND FIND THE RIGHT PRICE:

1. VISUAL ANALYSIS (if image provided):
   - Study the image carefully
   - Assess quality, materials, craftsmanship
   - Look for brand marks, artist signatures
   - Estimate production complexity

2. COST-BASED ANALYSIS (if cost available):
   - What markup makes sense for this product category?
   - Import items: typically 2-4x markup
   - Domestic items: typically 2-3x markup
   - Heady/art items: typically 3-10x markup depending on artist
   - Calculate: what price gives reasonable margin?

3. CATEGORY NORMS:
   - What do similar ${productIdentity.productType || 'products'} typically sell for?
   - Consider the quality tier: ${originTier} items have expected price ranges
   - Import ${productIdentity.productType}: usually $5-50
   - Domestic ${productIdentity.productType}: usually $20-150
   - Heady ${productIdentity.productType}: usually $50-500+

4. CURRENT PRICE EVALUATION:
   - Is $${currentPrice.toFixed(2)} reasonable for this product?
   - Does it align with the quality tier?
   - Would a customer feel it's fair value?

5. MARGIN REQUIREMENTS:
   - Minimum acceptable margin is 20% or $3
   - What's the floor price based on cost?

6. FINAL DETERMINATION:
   - Weigh all factors above (especially visual analysis if image provided)
   - Make a decisive recommendation
   - You MUST provide a price - don't give up

Respond in JSON:
{
    "deliberatedPrice": <number - YOUR FINAL PRICE RECOMMENDATION>,
    "confidence": "high" | "medium" | "low",
    "confidenceReason": "<why this confidence level>",
    "visualAnalysis": "<what you observed in the image - quality, materials, features>",
    "reasoning": {
        "costAnalysis": "<your cost-based reasoning>",
        "categoryNorms": "<what similar items typically cost>",
        "currentPriceAssessment": "<is current price reasonable?>",
        "marginCheck": "<does price meet margin requirements?>",
        "finalDecision": "<summary of your decision>"
    },
    "priceFloor": <minimum acceptable price>,
    "priceCeiling": <maximum reasonable price>,
    "alternativeConsiderations": "<any other factors considered>",
    "suggestedAction": "keep" | "increase" | "decrease"
}`;

        // Build message content - include image if available for visual analysis
        const messageContent = [];

        messageContent.push({
            type: 'text',
            text: deliberationPrompt
        });

        // Add product image for visual analysis during deliberation
        if (product.image) {
            let imageUrl = product.image;
            if (imageUrl.startsWith('//')) {
                imageUrl = 'https:' + imageUrl;
            }
            // Use full size for detailed analysis
            imageUrl = imageUrl.replace(/_\d+x\d*\./, '.');

            messageContent.push({
                type: 'image_url',
                image_url: { url: imageUrl, detail: 'high' }
            });
            console.log(`[${product.title}] Including image in deliberation for visual analysis`);
        }

        try {
            const res = await fetch('https://api.openai.com/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${settings.openaiKey}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    model: 'gpt-4o',
                    messages: [
                        {
                            role: 'system',
                            content: `You are an expert pricing strategist who NEVER gives up. When competitor data is unavailable, you use visual analysis of the product image, cost analysis, category knowledge, and business logic to determine optimal pricing. You MUST always provide a concrete price recommendation. If an image is provided, study it CAREFULLY for quality indicators.`
                        },
                        { role: 'user', content: messageContent }
                    ],
                    temperature: 0.6,
                    max_tokens: 1500,
                    response_format: { type: 'json_object' }
                })
            });

            if (!res.ok) {
                console.warn('Deliberation API call failed');
                return initialAnalysis;
            }

            const data = await res.json();
            const deliberation = JSON.parse(data.choices[0].message.content);

            console.log(`[${product.title}] Deliberation result: $${deliberation.deliberatedPrice}`);

            // Merge deliberation into analysis
            return {
                ...initialAnalysis,
                suggestedPrice: deliberation.deliberatedPrice,
                confidence: deliberation.confidence,
                confidenceReason: deliberation.confidenceReason,
                priceFloor: deliberation.priceFloor || initialAnalysis.priceFloor,
                priceCeiling: deliberation.priceCeiling || initialAnalysis.priceCeiling,
                reasoning: [
                    ...(initialAnalysis.reasoning || []),
                    `DELIBERATION: ${deliberation.reasoning?.finalDecision || 'Price determined through deep analysis'}`
                ],
                deliberation: deliberation,
                wasDeliberated: true
            };
        } catch (e) {
            console.error('Deliberation error:', e);
            return initialAnalysis;
        }
    }

    // ============================================================================
    // PRODUCT TABLE RENDERING
    // ============================================================================
    function populateFilters() {
        const vendors = [...new Set(state.products.map(p => p.vendor).filter(Boolean))];
        const types = [...new Set(state.products.map(p => p.productType).filter(Boolean))];

        const vendorSelect = document.getElementById('filter-vendor');
        vendorSelect.innerHTML = '<option value="">All Vendors</option>' +
            vendors.map(v => `<option value="${v}">${v}</option>`).join('');
    }

    function filterProducts() {
        const search = document.getElementById('search-input').value.toLowerCase();
        const status = document.getElementById('filter-status').value;
        const margin = document.getElementById('filter-margin').value;
        const vendor = document.getElementById('filter-vendor').value;
        const sort = document.getElementById('filter-sort').value;

        let filtered = [...state.products];

        // Search filter
        if (search) {
            filtered = filtered.filter(p =>
                p.title.toLowerCase().includes(search) ||
                p.vendor?.toLowerCase().includes(search) ||
                p.variants.some(v => v.sku?.toLowerCase().includes(search))
            );
        }

        // Vendor filter
        if (vendor) {
            filtered = filtered.filter(p => p.vendor === vendor);
        }

        // Status filter
        if (status) {
            filtered = filtered.filter(p => {
                const analysis = state.analysisCache[p.id];
                const variant = p.variants[0];
                const marginPct = variant.cost ? ((variant.price - variant.cost) / variant.price) * 100 : null;

                switch (status) {
                    case 'Needs Analysis': return !analysis;
                    case 'Has Suggestion': return analysis && !analysis.applied;
                    case 'Updated': return analysis && analysis.applied;
                    case 'Failed': return analysis && analysis.error;
                    case 'Negative Margin': return marginPct !== null && marginPct < 0;
                    case 'Below Floor': return marginPct !== null && marginPct < (getSettings().minMargin || 20);
                    case 'Missing Cost': return !variant.cost;
                    default: return true;
                }
            });
        }

        // Margin filter
        if (margin) {
            filtered = filtered.filter(p => {
                const variant = p.variants[0];
                if (!variant.cost) return margin === 'missing';
                const marginPct = ((variant.price - variant.cost) / variant.price) * 100;
                switch (margin) {
                    case 'negative': return marginPct < 0;
                    case 'low': return marginPct >= 0 && marginPct < 15;
                    case 'target': return marginPct >= 15 && marginPct <= 30;
                    case 'high': return marginPct > 30;
                    default: return true;
                }
            });
        }

        // Sorting
        filtered.sort((a, b) => {
            const av = a.variants[0], bv = b.variants[0];
            switch (sort) {
                case 'name-asc': return a.title.localeCompare(b.title);
                case 'name-desc': return b.title.localeCompare(a.title);
                case 'price-asc': return av.price - bv.price;
                case 'price-desc': return bv.price - av.price;
                case 'margin-asc':
                    const am = av.cost ? (av.price - av.cost) / av.price : -999;
                    const bm = bv.cost ? (bv.price - bv.cost) / bv.price : -999;
                    return am - bm;
                case 'margin-desc':
                    const am2 = av.cost ? (av.price - av.cost) / av.price : -999;
                    const bm2 = bv.cost ? (bv.price - bv.cost) / bv.price : -999;
                    return bm2 - am2;
                case 'analyzed-desc':
                    const aa = state.analysisCache[a.id]?.analyzedAt || '';
                    const ba = state.analysisCache[b.id]?.analyzedAt || '';
                    return ba.localeCompare(aa);
                default: return 0;
            }
        });

        state.filteredProducts = filtered;
        state.currentPage = 1;
        renderProducts();
    }

    function renderProducts() {
        const tbody = document.getElementById('product-table-body');
        const emptyState = document.getElementById('empty-state');

        if (state.products.length === 0) {
            tbody.innerHTML = '';
            emptyState.classList.remove('hidden');
            document.getElementById('showing-count').textContent = '0';
            return;
        }

        emptyState.classList.add('hidden');

        const start = (state.currentPage - 1) * state.pageSize;
        const end = start + state.pageSize;
        const pageProducts = state.filteredProducts.slice(start, end);

        tbody.innerHTML = pageProducts.map(product => {
            const variant = product.variants[0];
            const analysis = state.analysisCache[product.id];
            const hasMultipleVariants = product.variants.length > 1;

            // Calculate margin
            let marginPct = null;
            let marginClass = 'text-gray-500';
            if (variant.cost && variant.cost > 0) {
                marginPct = ((variant.price - variant.cost) / variant.price) * 100;
                if (marginPct < 0) marginClass = 'text-red-400 bg-red-900/20';
                else if (marginPct < 15) marginClass = 'text-yellow-400';
                else marginClass = 'text-green-400';
            }

            // Status badge - show deep analysis indicator
            let statusBadge = '';
            const deepBadge = analysis?.isDeep ? '<span class="ml-1 text-purple-400" title="Deep analyzed">◆</span>' : '';
            if (analysis?.error) {
                statusBadge = '<span class="px-2 py-1 text-xs rounded bg-red-900/50 text-red-400">Failed</span>';
            } else if (analysis?.applied) {
                statusBadge = `<span class="px-2 py-1 text-xs rounded bg-green-900/50 text-green-400">Updated${deepBadge}</span>`;
            } else if (analysis?.suggestedPrice) {
                statusBadge = `<span class="px-2 py-1 text-xs rounded bg-blue-900/50 text-blue-400">Review${deepBadge}</span>`;
            } else if (analysis?.analyzing) {
                const step = analysis.step || 'Analyzing...';
                const isDeepAnalysis = analysis.isDeep ? 'bg-purple-900/50 text-purple-400' : 'bg-yellow-900/50 text-yellow-400';
                statusBadge = `<span class="px-2 py-1 text-xs rounded ${isDeepAnalysis} animate-pulse-dot">${step}</span>`;
            } else {
                statusBadge = '<span class="px-2 py-1 text-xs rounded bg-gray-700 text-gray-400">—</span>';
            }

            // Suggested price display
            let suggestedDisplay = '—';
            if (analysis?.suggestedPrice && !analysis.applied) {
                const delta = analysis.suggestedPrice - variant.price;
                const deltaPct = (delta / variant.price) * 100;
                const sign = delta >= 0 ? '+' : '';
                suggestedDisplay = `
                    <span class="text-blue-400 font-medium">$${analysis.suggestedPrice.toFixed(2)}</span>
                    <span class="text-xs ${delta >= 0 ? 'text-green-400' : 'text-red-400'}">(${sign}$${delta.toFixed(2)} / ${sign}${deltaPct.toFixed(1)}%)</span>
                `;
            }

            // Action buttons - deep search is now the default
            let actionButtons = '';
            if (analysis?.error) {
                actionButtons = `
                    <button onclick="analyzeProduct('${product.id}')" class="px-3 py-1 text-xs bg-gray-700 hover:bg-gray-600 rounded">Retry</button>
                `;
            } else if (analysis?.suggestedPrice && !analysis.applied) {
                actionButtons = `
                    <button onclick="acceptSuggestion('${product.id}')" class="px-3 py-1 text-xs bg-green-600 hover:bg-green-700 rounded">Accept</button>
                    <button onclick="showProductDetail('${product.id}')" class="px-3 py-1 text-xs bg-gray-700 hover:bg-gray-600 rounded">View</button>
                    <button onclick="analyzeProduct('${product.id}')" class="px-3 py-1 text-xs bg-blue-600 hover:bg-blue-700 rounded" title="Re-analyze">↻</button>
                    <button onclick="clearSuggestion('${product.id}')" class="px-2 py-1 text-xs text-gray-500 hover:text-red-400" title="Clear suggestion">✕</button>
                `;
            } else if (analysis?.applied) {
                actionButtons = `
                    <button onclick="analyzeProduct('${product.id}')" class="px-3 py-1 text-xs bg-gray-700 hover:bg-gray-600 rounded">Re-analyze</button>
                `;
            } else {
                actionButtons = `
                    <button onclick="analyzeProduct('${product.id}')" class="px-3 py-1 text-xs bg-blue-600 hover:bg-blue-700 rounded">Analyze</button>
                `;
            }

            // Product image thumbnail
            const imageUrl = product.image ? product.image.replace(/\.([^.]+)$/, '_100x100.$1') : null;

            return `
                <tr class="border-b border-gray-700 hover:bg-gray-800/50 ${state.selectedProducts.has(product.id) ? 'bg-blue-900/20' : ''}">
                    <td class="px-4 py-3">
                        <input type="checkbox" class="product-checkbox rounded bg-gray-700 border-gray-600"
                            data-id="${product.id}" ${state.selectedProducts.has(product.id) ? 'checked' : ''}>
                    </td>
                    <td class="px-2 py-2">
                        ${imageUrl
                            ? `<img src="${imageUrl}" alt="" class="w-12 h-12 object-cover rounded cursor-pointer hover:opacity-80" onclick="showProductDetail('${product.id}')" loading="lazy">`
                            : `<div class="w-12 h-12 bg-gray-700 rounded flex items-center justify-center text-gray-500 text-xs">No img</div>`
                        }
                    </td>
                    <td class="px-4 py-3 cursor-pointer" onclick="showProductDetail('${product.id}')">
                        <div class="font-medium">${product.title}</div>
                        <div class="text-xs text-gray-500">${product.vendor || 'No vendor'}</div>
                        ${hasMultipleVariants ? `<span class="inline-block mt-1 px-2 py-0.5 text-xs bg-gray-700 rounded">${product.variants.length} variants</span>` : ''}
                    </td>
                    <td class="px-4 py-3 text-gray-400">${variant.sku || '—'}</td>
                    <td class="px-4 py-3 text-right font-medium">$${variant.price.toFixed(2)}</td>
                    <td class="px-4 py-3 text-right">
                        ${variant.cost ? `$${variant.cost.toFixed(2)}` : '<span class="text-gray-500 cursor-pointer hover:text-blue-400" onclick="editCost(\''+product.id+'\', \''+variant.id+'\')">Add cost</span>'}
                    </td>
                    <td class="px-4 py-3 text-right ${marginClass}">
                        ${marginPct !== null ? marginPct.toFixed(1) + '%' : '—'}
                    </td>
                    <td class="px-4 py-3 text-right">${suggestedDisplay}</td>
                    <td class="px-4 py-3 text-center">${statusBadge}</td>
                    <td class="px-4 py-3 text-center space-x-1">${actionButtons}</td>
                </tr>
            `;
        }).join('');

        // Update pagination
        const totalPages = Math.ceil(state.filteredProducts.length / state.pageSize);
        document.getElementById('page-info').textContent = `Page ${state.currentPage} of ${totalPages || 1}`;
        document.getElementById('prev-page').disabled = state.currentPage <= 1;
        document.getElementById('next-page').disabled = state.currentPage >= totalPages;
        document.getElementById('showing-count').textContent = state.filteredProducts.length;

        // Bind checkboxes
        document.querySelectorAll('.product-checkbox').forEach(cb => {
            cb.addEventListener('change', (e) => {
                const id = parseInt(e.target.dataset.id);
                if (e.target.checked) {
                    state.selectedProducts.add(id);
                } else {
                    state.selectedProducts.delete(id);
                }
                updateBulkActionBar();
            });
        });
    }

    function updateBulkActionBar() {
        const bar = document.getElementById('bulk-action-bar');
        const count = state.selectedProducts.size;

        if (count > 0) {
            bar.classList.remove('hidden');
            document.getElementById('selected-count').textContent = `${count} product${count > 1 ? 's' : ''} selected`;

            // Check if any selected have suggestions
            const hasSuggestions = [...state.selectedProducts].some(id => {
                const analysis = state.analysisCache[id];
                return analysis?.suggestedPrice && !analysis.applied;
            });
            document.getElementById('accept-all-btn').disabled = !hasSuggestions;
        } else {
            bar.classList.add('hidden');
        }
    }

    // ============================================================================
    // PRODUCT ANALYSIS
    // ============================================================================
    async function analyzeProduct(productId, options = {}) {
        const product = state.products.find(p => p.id == productId);
        if (!product) return;

        const settings = getSettings();
        // Deep search is now the default for all analyses
        const isDeep = options.deep !== false;
        const modeLabel = ''; // No need to label since deep is default

        // Update UI to show analyzing
        state.analysisCache[productId] = { analyzing: true, step: `${modeLabel}Identifying product...`, isDeep };
        renderProducts();

        try {
            // Step 1: Identify product using AI + image analysis
            console.log(`[${product.title}] ${modeLabel}Step 1: Identifying product...`);
            const productIdentity = await identifyProduct(product, settings);
            console.log(`[${product.title}] Identified as: ${productIdentity.identifiedAs}`);

            // Step 3: Multi-attempt search with progressively broader strategies
            let competitorData = { competitors: [], rawResults: [], excluded: [], queries: [] };
            let searchAttempt = 0;
            const maxSearchAttempts = 3;
            let allFoundPrices = [];

            while (searchAttempt < maxSearchAttempts) {
                searchAttempt++;
                const attemptLabel = searchAttempt > 1 ? ` (Attempt ${searchAttempt}/${maxSearchAttempts})` : '';

                state.analysisCache[productId] = {
                    analyzing: true,
                    step: `Searching competitors${attemptLabel}...`,
                    isDeep
                };
                renderProducts();

                console.log(`[${product.title}] Search attempt ${searchAttempt}/${maxSearchAttempts}`);

                // Get search strategy based on attempt number
                const searchOptions = {
                    deep: isDeep,
                    attempt: searchAttempt,
                    broadeningLevel: searchAttempt - 1 // 0 = specific, 1 = broader, 2 = broadest
                };

                const attemptResults = await searchCompetitors(product, productIdentity, settings, searchOptions);

                // Merge results
                competitorData.queries = [...competitorData.queries, ...attemptResults.queries];
                for (const comp of attemptResults.competitors) {
                    if (!allFoundPrices.includes(comp.price)) {
                        competitorData.competitors.push(comp);
                        allFoundPrices.push(comp.price);
                    }
                }
                competitorData.rawResults = [...competitorData.rawResults, ...attemptResults.rawResults];
                competitorData.excluded = [...competitorData.excluded, ...attemptResults.excluded];

                // Check if we have enough data
                const foundEnough = competitorData.competitors.length >= 2;
                console.log(`[${product.title}] After attempt ${searchAttempt}: ${competitorData.competitors.length} prices found`);

                if (foundEnough) {
                    console.log(`[${product.title}] Sufficient competitor data found!`);
                    break;
                }

                if (searchAttempt < maxSearchAttempts) {
                    console.log(`[${product.title}] Not enough data, broadening search...`);
                }
            }

            console.log(`[${product.title}] Total: ${competitorData.competitors.length} prices from ${competitorData.queries.length} queries`);

            state.analysisCache[productId] = { analyzing: true, step: 'Analyzing pricing...', isDeep };
            renderProducts();

            // Step 4: AI analysis with retail focus and fuzzy matching
            console.log(`[${product.title}] Step 4: Analyzing pricing...`);
            let analysis = await analyzeWithAI(product, competitorData, productIdentity, settings);
            console.log(`[${product.title}] Initial suggested price: $${analysis.suggestedPrice?.toFixed(2)} (${analysis.confidence} confidence, ${analysis.competitorAnalysis?.retailCount || 0} competitors)`);

            // Step 5: If still insufficient data, try alternative searches
            const hasInsufficientData = (analysis.competitorAnalysis?.retailCount || 0) < 2;
            const hasLowConfidence = analysis.confidence === 'low';

            if (hasInsufficientData || hasLowConfidence) {
                console.log(`[${product.title}] Step 5: Trying alternative search strategies...`);
                state.analysisCache[productId] = { analyzing: true, step: 'Trying alternative searches...', isDeep };
                renderProducts();

                const altResults = await tryAlternativeSearches(product, productIdentity, settings);
                const altPrices = altResults.filter(r => r.price).map(r => r.price);
                console.log(`[${product.title}] Alternative search found ${altPrices.length} prices: ${altPrices.map(p => '$' + p.toFixed(2)).join(', ')}`);

                // If we found new prices, add them to context for deliberation
                if (altPrices.length > 0) {
                    analysis.alternativePricesFound = altPrices;
                }
            }

            // Step 6: Deep deliberation if still uncertain
            if (hasInsufficientData || hasLowConfidence || !analysis.suggestedPrice) {
                console.log(`[${product.title}] Step 6: Deliberating on pricing...`);
                state.analysisCache[productId] = { analyzing: true, step: 'Deep deliberation...', isDeep };
                renderProducts();

                analysis = await deliberatePricing(product, analysis, competitorData, productIdentity, settings);
                console.log(`[${product.title}] Final deliberated price: $${analysis.suggestedPrice?.toFixed(2)}`);
            }

            // Store result - only keep essential data to avoid localStorage quota issues
            const trimmedAnalysis = {
                suggestedPrice: analysis.suggestedPrice,
                confidence: analysis.confidence,
                confidenceReason: analysis.confidenceReason,
                summary: analysis.summary,
                reasoning: (analysis.reasoning || []).slice(0, 5),
                marketPosition: analysis.marketPosition,
                priceFloor: analysis.priceFloor,
                priceCeiling: analysis.priceCeiling,
                productMatch: analysis.productMatch,
                competitorAnalysis: {
                    kept: (analysis.competitorAnalysis?.kept || []).slice(0, 10),
                    excluded: (analysis.competitorAnalysis?.excluded || []).slice(0, 5),
                    low: analysis.competitorAnalysis?.low,
                    median: analysis.competitorAnalysis?.median,
                    high: analysis.competitorAnalysis?.high,
                    retailCount: analysis.competitorAnalysis?.retailCount
                },
                productIdentity: {
                    identifiedAs: productIdentity.identifiedAs,
                    productSummary: productIdentity.productSummary,
                    productType: productIdentity.productType,
                    originTier: productIdentity.originTier,
                    originReasoning: productIdentity.originReasoning,
                    keyFeatures: (productIdentity.keyFeatures || []).slice(0, 5),
                    qualityIndicators: productIdentity.qualityIndicators,
                    pricingFactors: productIdentity.pricingFactors,
                    confidence: productIdentity.confidence,
                    brand: productIdentity.brand,
                    notes: productIdentity.notes
                },
                analyzedAt: new Date().toISOString(),
                applied: false,
                isDeep: isDeep,
                wasDeliberated: analysis.wasDeliberated || false,
                searchQueries: competitorData.queries.slice(0, 20) // Store queries used for debugging
            };

            state.analysisCache[productId] = trimmedAnalysis;

            try {
                localStorage.setItem('oilslick_analysis', JSON.stringify(state.analysisCache));
            } catch (storageError) {
                console.warn('localStorage full, clearing old analyses');
                // If storage is full, keep only most recent 100 analyses
                const entries = Object.entries(state.analysisCache);
                entries.sort((a, b) => (b[1].analyzedAt || '').localeCompare(a[1].analyzedAt || ''));
                state.analysisCache = Object.fromEntries(entries.slice(0, 100));
                localStorage.setItem('oilslick_analysis', JSON.stringify(state.analysisCache));
            }

            const deliberatedLabel = analysis.wasDeliberated ? ' [DELIBERATED]' : '';
            logActivity(`Analysis complete: ${product.title} → $${analysis.suggestedPrice?.toFixed(2) || 'N/A'} (${analysis.confidence} confidence, ${analysis.competitorAnalysis?.retailCount || 0} competitors)${deliberatedLabel}`);

        } catch (e) {
            console.error('Analysis error:', e);
            state.analysisCache[productId] = { error: e.message };
            showToast(`Analysis failed: ${e.message}`, 'error');
        }

        renderProducts();
        updateDashboard();
    }

    // Deep analysis with more search queries and page fetches
    async function deepAnalyzeProduct(productId) {
        return analyzeProduct(productId, { deep: true });
    }

    // Clear suggestion for a product and optionally re-analyze
    function clearSuggestion(productId, reanalyze = false) {
        delete state.analysisCache[productId];
        localStorage.setItem('oilslick_analysis', JSON.stringify(state.analysisCache));
        renderProducts();
        updateDashboard();
        showToast('Suggestion cleared', 'success');

        if (reanalyze) {
            analyzeProduct(productId);
        }
    }

    // Clear all suggestions
    function clearAllSuggestions() {
        if (!confirm('Clear all pricing suggestions? This cannot be undone.')) return;
        state.analysisCache = {};
        localStorage.setItem('oilslick_analysis', JSON.stringify(state.analysisCache));
        renderProducts();
        updateDashboard();
        showToast('All suggestions cleared', 'success');
    }

    async function analyzeSelected() {
        if (state.processing) return;
        state.processing = true;
        state.stopRequested = false;

        const settings = getSettings();
        const concurrency = settings.concurrency || 20;
        const ids = [...state.selectedProducts];

        document.getElementById('stop-btn').classList.remove('hidden');

        // Process in batches
        for (let i = 0; i < ids.length && !state.stopRequested; i += concurrency) {
            const batch = ids.slice(i, i + concurrency);
            await Promise.all(batch.map(id => analyzeProduct(id)));
        }

        state.processing = false;
        document.getElementById('stop-btn').classList.add('hidden');

        if (state.stopRequested) {
            showToast('Processing stopped', 'warning');
        } else {
            showToast(`Analyzed ${ids.length} products`, 'success');
            logActivity(`Bulk analysis: ${ids.length} products processed`);
        }
    }

    async function analyzeVisible() {
        const ids = state.filteredProducts.map(p => p.id);
        state.selectedProducts = new Set(ids);
        updateBulkActionBar();
        await analyzeSelected();
    }

    function stopProcessing() {
        state.stopRequested = true;
    }

    async function acceptSuggestion(productId) {
        const product = state.products.find(p => p.id == productId);
        const analysis = state.analysisCache[productId];

        if (!product || !analysis?.suggestedPrice) return;

        try {
            const variant = product.variants[0];
            await updateProductPrice(productId, variant.id, analysis.suggestedPrice);

            state.analysisCache[productId].applied = true;
            localStorage.setItem('oilslick_analysis', JSON.stringify(state.analysisCache));

            showToast(`Price updated to $${analysis.suggestedPrice.toFixed(2)}`, 'success');
            renderProducts();
            updateDashboard();

        } catch (e) {
            showToast('Failed to update price: ' + e.message, 'error');
        }
    }

    async function acceptAllSelected() {
        const selectedWithSuggestions = [...state.selectedProducts].filter(id => {
            const analysis = state.analysisCache[id];
            return analysis?.suggestedPrice && !analysis.applied;
        });

        let success = 0, failed = 0;

        for (const id of selectedWithSuggestions) {
            try {
                await acceptSuggestion(id);
                success++;
            } catch (e) {
                failed++;
            }
        }

        showToast(`Updated ${success} prices${failed > 0 ? `, ${failed} failed` : ''}`, success > 0 ? 'success' : 'error');
    }

    function deselectAll() {
        state.selectedProducts.clear();
        updateBulkActionBar();
        renderProducts();
    }

    // ============================================================================
    // PRODUCT DETAIL MODAL
    // ============================================================================
    function showProductDetail(productId) {
        const product = state.products.find(p => p.id == productId);
        if (!product) return;

        const variant = product.variants[0];
        const analysis = state.analysisCache[productId];
        const settings = getSettings();

        document.getElementById('modal-product-title').textContent = product.title;

        let content = '';

        // Product image and basic info header
        const productImage = product.image ? product.image.replace(/\.([^.]+)$/, '_400x400.$1') : null;
        content += `
            <div class="flex gap-6 mb-6">
                <div class="flex-shrink-0">
                    ${productImage
                        ? `<img src="${productImage}" alt="${product.title}" class="w-32 h-32 object-cover rounded-lg border border-gray-700">`
                        : `<div class="w-32 h-32 bg-gray-700 rounded-lg flex items-center justify-center text-gray-500">No image</div>`
                    }
                </div>
                <div class="flex-1">
                    <div class="grid grid-cols-2 gap-x-6 gap-y-2 text-sm">
                        <div>
                            <span class="text-gray-500">Vendor:</span>
                            <span class="ml-2">${product.vendor || 'Unknown'}</span>
                        </div>
                        <div>
                            <span class="text-gray-500">Type:</span>
                            <span class="ml-2">${product.productType || 'Unknown'}</span>
                        </div>
                        <div>
                            <span class="text-gray-500">SKU:</span>
                            <span class="ml-2 font-mono text-xs">${variant.sku || 'None'}</span>
                        </div>
                        <div>
                            <span class="text-gray-500">Handle:</span>
                            <span class="ml-2 font-mono text-xs">${product.handle || 'None'}</span>
                        </div>
                        ${product.tags ? `
                        <div class="col-span-2">
                            <span class="text-gray-500">Tags:</span>
                            <span class="ml-2 text-xs">${product.tags}</span>
                        </div>
                        ` : ''}
                    </div>
                    ${product.description ? `
                    <div class="mt-3">
                        <span class="text-gray-500 text-sm">Description:</span>
                        <p class="text-xs text-gray-400 mt-1 line-clamp-3">${(product.description || '').substring(0, 200)}${product.description?.length > 200 ? '...' : ''}</p>
                    </div>
                    ` : ''}
                </div>
            </div>
        `;

        // Variants section (if multiple)
        if (product.variants.length > 1) {
            content += `
                <div class="mb-6">
                    <h4 class="text-sm font-medium text-gray-400 mb-2">Variants (${product.variants.length})</h4>
                    <table class="w-full text-sm">
                        <thead>
                            <tr class="text-left text-gray-500 border-b border-gray-700">
                                <th class="py-2">Option</th>
                                <th class="py-2">SKU</th>
                                <th class="py-2 text-right">Price</th>
                                <th class="py-2 text-right">Cost</th>
                                <th class="py-2 text-right">Margin</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${product.variants.map(v => {
                                const margin = v.cost ? ((v.price - v.cost) / v.price * 100) : null;
                                const marginClass = margin === null ? 'text-gray-500' : margin < 0 ? 'text-red-400' : margin < 15 ? 'text-yellow-400' : 'text-green-400';
                                return `
                                    <tr class="border-b border-gray-700/50">
                                        <td class="py-2">${v.title}</td>
                                        <td class="py-2 text-gray-400">${v.sku || '—'}</td>
                                        <td class="py-2 text-right">$${v.price.toFixed(2)}</td>
                                        <td class="py-2 text-right">${v.cost ? '$' + v.cost.toFixed(2) : '—'}</td>
                                        <td class="py-2 text-right ${marginClass}">${margin !== null ? margin.toFixed(1) + '%' : '—'}</td>
                                    </tr>
                                `;
                            }).join('')}
                        </tbody>
                    </table>
                </div>
            `;
        }

        // Product metadata
        content += `
            <div class="mb-6">
                <h4 class="text-sm font-medium text-gray-400 mb-3">Product Setup</h4>
                <div class="grid grid-cols-2 gap-4">
                    <div>
                        <label class="block text-xs text-gray-500 mb-1">Category</label>
                        <select id="meta-category" class="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-sm">
                            <option>Commodity</option>
                            <option selected>Branded</option>
                            <option>Differentiated</option>
                            <option>Luxury</option>
                            <option>Seasonal</option>
                        </select>
                    </div>
                    <div>
                        <label class="block text-xs text-gray-500 mb-1">Lifecycle</label>
                        <select id="meta-lifecycle" class="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-sm">
                            <option>New</option>
                            <option selected>Core</option>
                            <option>Tail</option>
                            <option>Clearance</option>
                        </select>
                    </div>
                    <div>
                        <label class="block text-xs text-gray-500 mb-1">MAP Price</label>
                        <input type="number" id="meta-map" step="0.01" placeholder="—"
                            class="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-sm">
                    </div>
                    <div>
                        <label class="block text-xs text-gray-500 mb-1">MSRP</label>
                        <input type="number" id="meta-msrp" step="0.01" value="${variant.compareAtPrice || ''}" placeholder="—"
                            class="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-sm">
                    </div>
                </div>
            </div>
        `;

        // AI Analysis Result
        if (analysis && !analysis.error && analysis.suggestedPrice) {
            const currentMargin = variant.cost ? ((variant.price - variant.cost) / variant.price * 100) : null;
            const suggestedMargin = variant.cost ? ((analysis.suggestedPrice - variant.cost) / analysis.suggestedPrice * 100) : null;
            const delta = analysis.suggestedPrice - variant.price;
            const deltaPct = (delta / variant.price) * 100;

            // Product Identification Section (new)
            if (analysis.productIdentity || analysis.productMatch) {
                const identity = analysis.productIdentity || {};
                const match = analysis.productMatch || {};
                const tierColors = {
                    'import': 'bg-orange-900/50 text-orange-400 border-orange-700',
                    'domestic': 'bg-blue-900/50 text-blue-400 border-blue-700',
                    'heady': 'bg-purple-900/50 text-purple-400 border-purple-700'
                };
                const tierLabels = {
                    'import': 'Import (China/Overseas)',
                    'domestic': 'Domestic (USA-Made)',
                    'heady': 'Heady (Handmade Art)'
                };
                const tier = identity.originTier || match.originTier || 'unknown';
                const tierClass = tierColors[tier] || 'bg-gray-700 text-gray-400 border-gray-600';
                const tierLabel = tierLabels[tier] || 'Unknown Origin';

                content += `
                    <div class="bg-blue-900/20 border border-blue-800 rounded-lg p-4 mb-6">
                        <div class="flex items-center justify-between mb-3">
                            <h4 class="text-sm font-medium text-blue-400">AI Product Analysis</h4>
                            <span class="px-3 py-1 text-xs font-medium rounded border ${tierClass}">${tierLabel}</span>
                        </div>

                        ${identity.productSummary ? `
                        <div class="bg-gray-800/50 rounded-lg p-3 mb-4">
                            <p class="text-sm text-gray-200 leading-relaxed">${identity.productSummary}</p>
                        </div>
                        ` : ''}

                        <div class="grid grid-cols-2 gap-4 text-sm">
                            <div>
                                <span class="text-gray-500">Identified as:</span>
                                <span class="ml-2 text-white">${identity.identifiedAs || match.identifiedAs || 'Unknown'}</span>
                            </div>
                            <div>
                                <span class="text-gray-500">Product type:</span>
                                <span class="ml-2">${identity.productType || 'Unknown'}</span>
                            </div>
                            <div>
                                <span class="text-gray-500">Brand:</span>
                                <span class="ml-2">${identity.brand || 'Unknown'}</span>
                            </div>
                            <div>
                                <span class="text-gray-500">AI confidence:</span>
                                <span class="ml-2 ${identity.confidence === 'high' ? 'text-green-400' : identity.confidence === 'medium' ? 'text-yellow-400' : 'text-gray-400'}">${identity.confidence || 'Unknown'}</span>
                            </div>
                        </div>

                        ${identity.keyFeatures?.length ? `
                            <div class="mt-3 text-sm">
                                <span class="text-gray-500">Key features:</span>
                                <div class="mt-1 flex flex-wrap gap-1">
                                    ${identity.keyFeatures.map(f => `<span class="px-2 py-0.5 bg-gray-700 rounded text-xs">${f}</span>`).join('')}
                                </div>
                            </div>
                        ` : ''}

                        ${identity.qualityIndicators?.length ? `
                            <div class="mt-3 text-sm">
                                <span class="text-gray-500">Quality indicators:</span>
                                <div class="mt-1 flex flex-wrap gap-1">
                                    ${identity.qualityIndicators.map(q => `<span class="px-2 py-0.5 bg-${tier === 'heady' ? 'purple' : tier === 'domestic' ? 'blue' : 'orange'}-900/50 rounded text-xs">${q}</span>`).join('')}
                                </div>
                            </div>
                        ` : ''}

                        ${identity.pricingFactors ? `
                            <div class="mt-3 text-sm">
                                <span class="text-gray-500">Pricing factors:</span>
                                <span class="ml-2 text-gray-300">${identity.pricingFactors}</span>
                            </div>
                        ` : ''}

                        ${identity.originReasoning ? `
                            <div class="mt-3 text-sm">
                                <span class="text-gray-500">Tier reasoning:</span>
                                <span class="ml-2 text-gray-400 text-xs">${identity.originReasoning}</span>
                            </div>
                        ` : ''}

                        ${identity.notes ? `<div class="mt-3 text-xs text-gray-500 italic">${identity.notes}</div>` : ''}
                    </div>
                `;
            }

            // Market Position Badge
            const marketPositionColors = {
                'below market': 'bg-green-900/50 text-green-400',
                'at market': 'bg-gray-700 text-gray-300',
                'above market': 'bg-yellow-900/50 text-yellow-400',
                'premium': 'bg-purple-900/50 text-purple-400',
                'unknown': 'bg-gray-700 text-gray-500'
            };
            const marketPosClass = marketPositionColors[analysis.marketPosition] || marketPositionColors['unknown'];

            content += `
                <div class="grid grid-cols-2 gap-6 mb-6">
                    <div class="bg-gray-700/50 rounded-lg p-4">
                        <h4 class="text-sm font-medium text-gray-400 mb-3">AI Recommendation</h4>
                        <div class="mb-4">
                            <div class="text-3xl font-semibold text-blue-400">$${analysis.suggestedPrice.toFixed(2)}</div>
                            <div class="text-sm ${delta >= 0 ? 'text-green-400' : 'text-red-400'}">
                                ${delta >= 0 ? '+' : ''}$${delta.toFixed(2)} (${delta >= 0 ? '+' : ''}${deltaPct.toFixed(1)}%)
                            </div>
                            <div class="flex items-center gap-2 mt-2">
                                <span class="text-xs px-2 py-1 rounded ${marketPosClass}">${analysis.marketPosition || 'unknown'}</span>
                                <span class="text-xs text-gray-500">${analysis.competitorAnalysis?.retailCount || 0} retail competitors</span>
                            </div>
                            <div class="text-xs text-gray-500 mt-1">
                                Confidence: <span class="${analysis.confidence === 'high' ? 'text-green-400' : analysis.confidence === 'medium' ? 'text-yellow-400' : 'text-red-400'}">${analysis.confidence}</span>
                                — ${analysis.confidenceReason}
                            </div>
                        </div>
                        <p class="text-sm text-gray-300 mb-4">${analysis.summary}</p>
                        <div class="flex flex-wrap gap-2">
                            ${!analysis.applied ? `
                                <button onclick="acceptSuggestion('${productId}'); closeModal();" class="px-4 py-2 bg-green-600 hover:bg-green-700 rounded text-sm">Accept</button>
                                <button onclick="editAndAccept('${productId}')" class="px-4 py-2 bg-gray-600 hover:bg-gray-500 rounded text-sm">Edit & Accept</button>
                                <button onclick="dismissSuggestion('${productId}')" class="px-4 py-2 text-gray-400 hover:text-white text-sm">Dismiss</button>
                            ` : '<span class="text-green-400 text-sm">Price updated</span>'}
                        </div>
                        <div class="flex gap-2 mt-3 pt-3 border-t border-gray-600">
                            <button onclick="closeModal(); analyzeProduct('${productId}');" class="px-3 py-1.5 bg-blue-600 hover:bg-blue-700 rounded text-xs flex items-center gap-1">
                                <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"/></svg>
                                Re-analyze
                            </button>
                            <button onclick="closeModal(); clearSuggestion('${productId}');" class="px-3 py-1.5 text-gray-400 hover:text-red-400 text-xs">
                                Clear Suggestion
                            </button>
                        </div>
                    </div>
                    <div class="bg-gray-700/50 rounded-lg p-4">
                        <h4 class="text-sm font-medium text-gray-400 mb-3">Retail Competitor Analysis</h4>
                        <div class="grid grid-cols-2 gap-x-4 gap-y-2 text-sm mb-4">
                            <div class="text-gray-500">Price Floor:</div>
                            <div>$${analysis.priceFloor?.toFixed(2) || '—'}</div>
                            <div class="text-gray-500">Price Ceiling:</div>
                            <div>$${analysis.priceCeiling?.toFixed(2) || '—'}</div>
                            <div class="text-gray-500">Retail Low:</div>
                            <div>$${analysis.competitorAnalysis?.low?.toFixed(2) || '—'}</div>
                            <div class="text-gray-500">Retail Median:</div>
                            <div class="font-medium">$${analysis.competitorAnalysis?.median?.toFixed(2) || '—'}</div>
                            <div class="text-gray-500">Retail High:</div>
                            <div>$${analysis.competitorAnalysis?.high?.toFixed(2) || '—'}</div>
                        </div>
                        <h5 class="text-xs font-medium text-gray-500 mb-2">AI Reasoning</h5>
                        <ul class="text-sm text-gray-400 space-y-1 max-h-32 overflow-auto">
                            ${(analysis.reasoning || []).map(r => `<li class="flex"><span class="mr-2">•</span>${r}</li>`).join('')}
                        </ul>
                    </div>
                </div>
            `;

            // Competitor sources (collapsible) - with clickable URLs for verification
            if (analysis.competitorAnalysis) {
                content += `
                    <details class="mb-6" open>
                        <summary class="text-sm font-medium text-gray-400 cursor-pointer hover:text-white">
                            Competitor Sources (${(analysis.competitorAnalysis.kept?.length || 0)} retail kept, ${(analysis.competitorAnalysis.excluded?.length || 0)} excluded) - Click links to verify
                        </summary>
                        <div class="mt-3 space-y-4">
                            <div class="text-xs text-gray-500">
                                Search queries used: ${(analysis.searchQueries || []).map(q => `"${q}"`).join(', ') || 'N/A'}
                            </div>
                            ${analysis.competitorAnalysis.kept?.length ? `
                                <div>
                                    <h5 class="text-xs font-medium text-green-500 mb-2">Retail Sources Kept (${analysis.competitorAnalysis.kept.length}) - Same Quality Tier</h5>
                                    <div class="space-y-2">
                                        ${analysis.competitorAnalysis.kept.map(s => `
                                            <div class="bg-gray-700/30 rounded p-2 border border-gray-700">
                                                <div class="flex items-center justify-between mb-1">
                                                    <span class="font-medium text-white">${s.source}</span>
                                                    <span class="text-lg font-bold text-green-400">$${s.price?.toFixed(2) || '—'}</span>
                                                </div>
                                                <div class="flex items-center gap-2 mb-1">
                                                    <span class="text-xs px-1.5 py-0.5 rounded ${s.productMatch === 'exact' ? 'bg-green-900/50 text-green-400' : s.productMatch === 'similar' ? 'bg-blue-900/50 text-blue-400' : 'bg-gray-700 text-gray-400'}">${s.productMatch || '—'} match</span>
                                                    <span class="text-xs text-gray-500">${s.reason}</span>
                                                </div>
                                                ${s.url ? `
                                                    <a href="${s.url}" target="_blank" rel="noopener noreferrer"
                                                       class="text-xs text-blue-400 hover:text-blue-300 underline break-all flex items-center gap-1">
                                                        <svg class="w-3 h-3 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14"/>
                                                        </svg>
                                                        ${s.url}
                                                    </a>
                                                ` : '<span class="text-xs text-gray-500">No URL available</span>'}
                                            </div>
                                        `).join('')}
                                    </div>
                                </div>
                            ` : '<p class="text-sm text-gray-500">No valid retail competitors found at the same quality tier</p>'}
                            ${analysis.competitorAnalysis.excluded?.length ? `
                                <details class="mt-2">
                                    <summary class="text-xs text-gray-500 cursor-pointer hover:text-gray-300">Show excluded sources (${analysis.competitorAnalysis.excluded.length})</summary>
                                    <div class="mt-2 space-y-1">
                                        ${analysis.competitorAnalysis.excluded.map(s => `
                                            <div class="flex items-center justify-between text-xs py-1 border-b border-gray-700/50">
                                                <div class="flex-1">
                                                    <span class="text-gray-500">${s.source}</span>
                                                    ${s.url ? `
                                                        <a href="${s.url}" target="_blank" rel="noopener noreferrer"
                                                           class="ml-2 text-gray-600 hover:text-gray-400 underline">
                                                            (view)
                                                        </a>
                                                    ` : ''}
                                                </div>
                                                <span class="text-red-400/70 ml-2">${s.reason}</span>
                                            </div>
                                        `).join('')}
                                    </div>
                                </details>
                            ` : ''}
                        </div>
                    </details>
                `;
            }

            // Profit comparison
            content += `
                <div>
                    <h4 class="text-sm font-medium text-gray-400 mb-3">Profit Impact</h4>
                    <div class="grid grid-cols-2 gap-4">
                        <div class="bg-gray-700/50 rounded p-3 text-center">
                            <div class="text-xs text-gray-500 mb-1">Current</div>
                            <div class="text-lg font-medium">$${variant.price.toFixed(2)}</div>
                            ${variant.cost ? `
                                <div class="text-sm text-gray-400">Profit: $${(variant.price - variant.cost).toFixed(2)}</div>
                                <div class="text-sm ${currentMargin < 0 ? 'text-red-400' : 'text-green-400'}">${currentMargin.toFixed(1)}% margin</div>
                            ` : ''}
                        </div>
                        <div class="bg-blue-900/30 border border-blue-800 rounded p-3 text-center">
                            <div class="text-xs text-blue-400 mb-1">Suggested</div>
                            <div class="text-lg font-medium text-blue-400">$${analysis.suggestedPrice.toFixed(2)}</div>
                            ${variant.cost ? `
                                <div class="text-sm text-gray-400">Profit: $${(analysis.suggestedPrice - variant.cost).toFixed(2)}</div>
                                <div class="text-sm ${suggestedMargin < 0 ? 'text-red-400' : 'text-green-400'}">${suggestedMargin.toFixed(1)}% margin</div>
                            ` : ''}
                        </div>
                    </div>
                </div>
            `;
        } else if (analysis?.error) {
            content += `
                <div class="bg-red-900/20 border border-red-800 rounded-lg p-4 mb-6">
                    <h4 class="text-red-400 font-medium mb-2">Analysis Failed</h4>
                    <p class="text-sm text-gray-400">${analysis.error}</p>
                    <button onclick="analyzeProduct('${productId}')" class="mt-3 px-4 py-2 bg-gray-700 hover:bg-gray-600 rounded text-sm">Retry Analysis</button>
                </div>
            `;
        } else {
            content += `
                <div class="bg-gray-700/50 rounded-lg p-6 text-center mb-6">
                    <p class="text-gray-400 mb-3">No analysis available for this product</p>
                    <button onclick="analyzeProduct('${productId}')" class="px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded text-sm">Run Analysis</button>
                </div>
            `;
        }

        document.getElementById('modal-content').innerHTML = content;
        document.getElementById('product-modal').classList.remove('hidden');
    }

    function closeModal() {
        document.getElementById('product-modal').classList.add('hidden');
    }

    function dismissSuggestion(productId) {
        delete state.analysisCache[productId];
        localStorage.setItem('oilslick_analysis', JSON.stringify(state.analysisCache));
        closeModal();
        renderProducts();
    }

    function editCost(productId, variantId) {
        const newCost = prompt('Enter cost for this product:');
        if (newCost !== null) {
            const cost = parseFloat(newCost);
            if (!isNaN(cost) && cost >= 0) {
                const product = state.products.find(p => p.id == productId);
                if (product) {
                    const variant = product.variants.find(v => v.id == variantId);
                    if (variant) {
                        variant.cost = cost;
                        localStorage.setItem('oilslick_products', JSON.stringify(getProductsForStorage(state.products)));
                        renderProducts();
                        showToast('Cost updated', 'success');
                    }
                }
            }
        }
    }

    // ============================================================================
    // DASHBOARD
    // ============================================================================
    function updateDashboard() {
        const settings = getSettings();
        const minMargin = settings.minMargin || 20;

        // Metrics
        document.getElementById('metric-total').textContent = state.products.length;

        // Average margin
        let totalMargin = 0, marginCount = 0;
        state.products.forEach(p => {
            const v = p.variants[0];
            if (v.cost && v.cost > 0) {
                totalMargin += ((v.price - v.cost) / v.price) * 100;
                marginCount++;
            }
        });
        const avgMargin = marginCount > 0 ? (totalMargin / marginCount) : null;
        const marginEl = document.getElementById('metric-margin');
        if (avgMargin !== null) {
            marginEl.textContent = avgMargin.toFixed(1) + '%';
            marginEl.className = 'text-2xl font-semibold ' +
                (avgMargin > 25 ? 'text-green-400' : avgMargin > 15 ? 'text-yellow-400' : 'text-red-400');
        } else {
            marginEl.textContent = '—';
            marginEl.className = 'text-2xl font-semibold';
        }

        // Analyzed count
        const analyzedCount = Object.keys(state.analysisCache).filter(k =>
            state.analysisCache[k].suggestedPrice && !state.analysisCache[k].error
        ).length;
        document.getElementById('metric-analyzed').textContent = `${analyzedCount} of ${state.products.length}`;
        document.getElementById('metric-analyzed-pct').textContent = state.products.length > 0
            ? `${Math.round(analyzedCount / state.products.length * 100)}% complete` : '';

        // Pending updates
        const pendingCount = Object.keys(state.analysisCache).filter(k =>
            state.analysisCache[k].suggestedPrice && !state.analysisCache[k].applied && !state.analysisCache[k].error
        ).length;
        document.getElementById('metric-pending').textContent = pendingCount;

        // Action cards
        const actionCards = document.getElementById('action-cards');
        let cards = '';

        // Negative margins
        const negativeMarginProducts = state.products.filter(p => {
            const v = p.variants[0];
            return v.cost && v.cost > 0 && v.price < v.cost;
        });
        if (negativeMarginProducts.length > 0) {
            cards += `
                <div class="bg-gray-800 border-l-4 border-red-500 rounded-lg p-4">
                    <h3 class="font-medium text-red-400">${negativeMarginProducts.length} products are losing money</h3>
                    <p class="text-sm text-gray-400 mt-1">Current price is below your cost</p>
                    <button onclick="navigateTo('products'); applyFilter('status', 'Negative Margin')"
                        class="mt-3 px-4 py-2 bg-red-600 hover:bg-red-700 rounded text-sm">Review & Fix</button>
                </div>
            `;
        }

        // Below floor
        const belowFloorProducts = state.products.filter(p => {
            const v = p.variants[0];
            if (!v.cost || v.cost <= 0) return false;
            const margin = ((v.price - v.cost) / v.price) * 100;
            return margin >= 0 && margin < minMargin;
        });
        if (belowFloorProducts.length > 0) {
            cards += `
                <div class="bg-gray-800 border-l-4 border-yellow-500 rounded-lg p-4">
                    <h3 class="font-medium text-yellow-400">${belowFloorProducts.length} products below margin floor</h3>
                    <p class="text-sm text-gray-400 mt-1">Priced below your ${minMargin}% minimum margin target</p>
                    <button onclick="navigateTo('products'); applyFilter('status', 'Below Floor')"
                        class="mt-3 px-4 py-2 bg-yellow-600 hover:bg-yellow-700 rounded text-sm">Review Suggestions</button>
                </div>
            `;
        }

        // Missing costs
        const missingCostProducts = state.products.filter(p => !p.variants[0].cost);
        if (missingCostProducts.length > 0) {
            cards += `
                <div class="bg-gray-800 border-l-4 border-blue-500 rounded-lg p-4">
                    <h3 class="font-medium text-blue-400">${missingCostProducts.length} products missing cost data</h3>
                    <p class="text-sm text-gray-400 mt-1">Cannot calculate margins without costs</p>
                    <button onclick="navigateTo('products'); applyFilter('status', 'Missing Cost')"
                        class="mt-3 px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded text-sm">Add Costs</button>
                </div>
            `;
        }

        // Ready to update
        if (pendingCount > 0) {
            cards += `
                <div class="bg-gray-800 border-l-4 border-green-500 rounded-lg p-4">
                    <h3 class="font-medium text-green-400">${pendingCount} price updates ready</h3>
                    <p class="text-sm text-gray-400 mt-1">AI suggestions waiting for your approval</p>
                    <button onclick="navigateTo('products'); applyFilter('status', 'Has Suggestion')"
                        class="mt-3 px-4 py-2 bg-green-600 hover:bg-green-700 rounded text-sm">Review & Apply</button>
                </div>
            `;
        }

        // Stale analysis (older than 7 days)
        const staleProducts = state.products.filter(p => {
            const analysis = state.analysisCache[p.id];
            if (!analysis?.analyzedAt) return false;
            const age = Date.now() - new Date(analysis.analyzedAt).getTime();
            return age > 7 * 24 * 60 * 60 * 1000;
        });
        if (staleProducts.length > 0) {
            cards += `
                <div class="bg-gray-800 border-l-4 border-gray-500 rounded-lg p-4">
                    <h3 class="font-medium text-gray-300">${staleProducts.length} products have stale data</h3>
                    <p class="text-sm text-gray-400 mt-1">Competitor data is over a week old</p>
                    <button onclick="navigateTo('products')"
                        class="mt-3 px-4 py-2 bg-gray-600 hover:bg-gray-500 rounded text-sm">Re-analyze</button>
                </div>
            `;
        }

        actionCards.innerHTML = cards || '<p class="text-gray-500 col-span-2 text-center py-8">No action items - your store is in good shape!</p>';

        // Activity feed
        const activityFeed = document.getElementById('activity-feed');
        if (state.activityLog.length > 0) {
            activityFeed.innerHTML = state.activityLog.slice(0, 10).map(a => `
                <div class="text-sm py-2 border-b border-gray-700 last:border-0">
                    <span class="text-gray-400">${a.message}</span>
                    <span class="text-xs text-gray-600 ml-2">${formatTime(a.timestamp)}</span>
                </div>
            `).join('');
        }
    }

    function applyFilter(type, value) {
        if (type === 'status') {
            document.getElementById('filter-status').value = value;
        } else if (type === 'sort') {
            document.getElementById('filter-sort').value = value;
        }
        filterProducts();
    }

    // ============================================================================
    // UTILITIES
    // ============================================================================
    function showToast(message, type = 'info') {
        const container = document.getElementById('toast-container');
        const colors = {
            success: 'bg-green-600',
            error: 'bg-red-600',
            warning: 'bg-yellow-600',
            info: 'bg-blue-600'
        };

        const toast = document.createElement('div');
        toast.className = `${colors[type]} px-4 py-3 rounded shadow-lg text-sm transform transition-all duration-300`;
        toast.textContent = message;
        container.appendChild(toast);

        setTimeout(() => {
            toast.style.opacity = '0';
            setTimeout(() => toast.remove(), 300);
        }, 3000);
    }

    function logActivity(message) {
        state.activityLog.unshift({
            message,
            timestamp: new Date().toISOString()
        });
        state.activityLog = state.activityLog.slice(0, 50);
        localStorage.setItem('oilslick_activity', JSON.stringify(state.activityLog));
    }

    function formatTime(isoString) {
        const date = new Date(isoString);
        const now = new Date();
        const diff = now - date;

        if (diff < 60000) return 'just now';
        if (diff < 3600000) return Math.floor(diff / 60000) + 'm ago';
        if (diff < 86400000) return Math.floor(diff / 3600000) + 'h ago';
        return date.toLocaleDateString();
    }

    function toggleSwitch(btn) {
        const enabled = btn.dataset.enabled === 'true';
        btn.dataset.enabled = !enabled;
        updateSwitchVisual(btn);
    }

    function updateSwitchVisual(btn) {
        const enabled = btn.dataset.enabled === 'true';
        const knob = btn.querySelector('span');
        if (enabled) {
            btn.classList.remove('bg-gray-600');
            btn.classList.add('bg-blue-600');
            knob.style.left = '1.25rem';
        } else {
            btn.classList.remove('bg-blue-600');
            btn.classList.add('bg-gray-600');
            knob.style.left = '0.125rem';
        }
    }

    function exportCSV() {
        const headers = ['Title', 'Vendor', 'SKU', 'Current Price', 'Cost', 'Margin %', 'Suggested Price', 'Status'];
        const rows = state.filteredProducts.map(p => {
            const v = p.variants[0];
            const analysis = state.analysisCache[p.id];
            const margin = v.cost ? ((v.price - v.cost) / v.price * 100).toFixed(1) : '';
            const status = analysis?.applied ? 'Updated' : analysis?.suggestedPrice ? 'Has Suggestion' : 'Needs Analysis';
            return [
                p.title,
                p.vendor || '',
                v.sku || '',
                v.price.toFixed(2),
                v.cost?.toFixed(2) || '',
                margin,
                analysis?.suggestedPrice?.toFixed(2) || '',
                status
            ];
        });

        const csv = [headers, ...rows].map(r => r.map(c => `"${c}"`).join(',')).join('\n');
        const blob = new Blob([csv], { type: 'text/csv' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `oilslick-pricing-${new Date().toISOString().split('T')[0]}.csv`;
        a.click();
        URL.revokeObjectURL(url);
    }

    // ============================================================================
    // EVENT LISTENERS
    // ============================================================================
    document.addEventListener('DOMContentLoaded', () => {
        loadSettings();

        // Slider value displays
        document.querySelectorAll('input[type="range"]').forEach(slider => {
            slider.addEventListener('input', (e) => {
                const valueEl = document.getElementById(e.target.id + '-value');
                if (valueEl) {
                    valueEl.textContent = e.target.value + (e.target.id !== 'concurrency' ? '%' : '');
                }
            });
        });

        // Filter inputs
        ['search-input', 'filter-status', 'filter-margin', 'filter-vendor', 'filter-sort'].forEach(id => {
            const el = document.getElementById(id);
            if (el) {
                el.addEventListener(el.type === 'text' ? 'input' : 'change', filterProducts);
            }
        });

        // Select all checkbox
        document.getElementById('select-all').addEventListener('change', (e) => {
            if (e.target.checked) {
                state.filteredProducts.forEach(p => state.selectedProducts.add(p.id));
            } else {
                state.selectedProducts.clear();
            }
            updateBulkActionBar();
            renderProducts();
        });

        // Pagination
        document.getElementById('page-size').addEventListener('change', (e) => {
            state.pageSize = parseInt(e.target.value);
            state.currentPage = 1;
            renderProducts();
        });

        document.getElementById('prev-page').addEventListener('click', () => {
            if (state.currentPage > 1) {
                state.currentPage--;
                renderProducts();
            }
        });

        document.getElementById('next-page').addEventListener('click', () => {
            const totalPages = Math.ceil(state.filteredProducts.length / state.pageSize);
            if (state.currentPage < totalPages) {
                state.currentPage++;
                renderProducts();
            }
        });

        // Modal close on backdrop click
        document.getElementById('product-modal').addEventListener('click', (e) => {
            if (e.target.id === 'product-modal') closeModal();
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') closeModal();
        });

        // Initial view
        state.filteredProducts = [...state.products];
        navigateTo('dashboard');

        // If we have products, render them
        if (state.products.length > 0) {
            populateFilters();
            updateDashboard();
        }
    });
    </script>
</body>
</html>
